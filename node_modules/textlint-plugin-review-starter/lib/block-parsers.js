// LICENSE : MIT
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlockParsers = void 0;
exports.parseBlockArg = parseBlockArg;
exports.parseBlockWithContent = parseBlockWithContent;
exports.supportedBlockCommands = supportedBlockCommands;

var _mapping = require("./mapping");

var _inlineParsers = require("./inline-parsers");

var _parserUtils = require("./parser-utils");

var BlockParsers = {
  table: withCaption(1, parseTable),
  footnote: parseFootnote,
  quote: parseQuote,
  bibpaper: withCaption(1, parseCodeBlock),
  list: withCaption(1, parseCodeBlock),
  listnum: withCaption(1, parseCodeBlock),
  emlist: withCaption(0, parseCodeBlock),
  emlistnum: withCaption(0, parseCodeBlock),
  source: parseCodeBlock,
  cmd: parseCodeBlock,
  texequation: parseCodeBlock,
  comment: parseCommentBlock,
  image: withCaption(1, parseImage),
  indepimage: withCaption(1, parseImage),
  numberlessimage: withCaption(1, parseImage),
  graph: withCaption(2, parseImage),
  imgtable: withCaption(1, parseImage),
  lead: parseLead,
  read: parseLead,
  note: withCaption(0, parseShortColumn),
  memo: withCaption(0, parseShortColumn),
  tip: withCaption(0, parseShortColumn),
  info: withCaption(0, parseShortColumn),
  warning: withCaption(0, parseShortColumn),
  important: withCaption(0, parseShortColumn),
  caution: withCaption(0, parseShortColumn),
  notice: withCaption(0, parseShortColumn),
  embed: parseRawBlock,
  raw: parseRawBlock,
  // operator
  blankline: parseOperator("\n"),
  noindent: parseOperator(null),
  tsize: parseOperator(null),
  // ---------- Starter ----------
  "abstract": parseLead,
  chapterauthor: parseLead,
  output: withCaption(1, parseCodeBlock),
  program: withCaption(1, parseCodeBlock),
  sideimage: withCaption(null, parseImage),
  terminal: parseCodeBlock,
  desc: withCaption(0, parseCodeBlock),
  desclist: parseCodeBlock,
  talk: withCaption(1, parseCodeBlock),
  talklist: parseCodeBlock,
  // operator
  centering: parseOperator(null),
  clearpage: parseOperator(null),
  flushright: parseOperator(null),
  makechaptitlepage: parseOperator(null),
  needvspace: parseOperator(null),
  paragraphend: parseOperator(null),
  sampleoutputbegin: parseOperator(null),
  sampleoutputend: parseOperator(null),
  vspace: parseOperator(null)
};
/**
 * return new parser to parse block with caption.
 * @param {number} captionIndex - index of caption in block args
 * @param {function} blockParser - Parser function of a block
 * @return {function} parser function
 */

exports.BlockParsers = BlockParsers;

function withCaption(captionIndex, blockParser) {
  return function (block) {
    var node = blockParser(block);

    if (captionIndex !== null) {
      var blockArg = block.args[captionIndex];

      if (blockArg) {
        var caption = parseBlockArg(_mapping.Syntax.Caption, blockArg, block.chunk.lines[0]);

        if (caption) {
          node.children = node.children || [];
          node.children.unshift(caption);
        }
      }
    }

    return node;
  };
}
/**
 * parse operator
 * @param {Block} block - Block to parse
 * @param {string} text - substitute text
 * @return {TxtNode}
 */


function parseOperator(text) {
  if (text == null) {
    return null;
  }

  return function (block) {
    var node = (0, _parserUtils.createNodeFromChunk)(block.chunk, _mapping.Syntax.Str);
    node.value = text;
    return node;
  };
}
/**
 * parse table block.
 * @param {Block} block - Block to parse
 * @return {TxtNode} Table node
 */


function parseTable(block) {
  var node = (0, _parserUtils.createNodeFromChunk)(block.chunk, _mapping.Syntax.Table);
  node.children = [];
  block.chunk.lines.slice(1, block.chunk.lines.length - 1).forEach(function (line) {
    Array.prototype.push.apply(node.children, parseTableContent(line));
  });
  return node;
}
/**
 * parse line in a table.
 * @param {Line} line - Line to parse
 * @return {[TxtNode]} ListItem nodes in the line
 */


function parseTableContent(line) {
  if (line.isComment) {
    return [(0, _parserUtils.createCommentNodeFromLine)(line)];
  }

  if (line.text.match(/^-+$/)) {
    return []; // Ignore horizontal line
  }

  var nodes = [];
  var cellRegex = /[^\t]+/g;
  var match;

  while (match = cellRegex.exec(line.text)) {
    var startColumn = match.index;
    var cellContent = match[0];

    if (cellContent.startsWith('.')) {
      cellContent = cellContent.substr(1);
      startColumn += 1;
    }

    if (cellContent === '') {
      continue;
    }

    var context = (0, _parserUtils.contextFromLine)(line, startColumn);
    var cellNode = (0, _parserUtils.createInlineNode)(_mapping.Syntax.TableCell, cellContent, context);
    cellNode.children = (0, _inlineParsers.parseText)(cellContent, context);
    nodes.push(cellNode);
  }

  return nodes;
}
/**
 * parse footnote block.
 * @param {Block} block - Block to parse
 * @return {TxtNode} Footnote node
 */


function parseFootnote(block) {
  var node = (0, _parserUtils.createNodeFromChunk)(block.chunk, _mapping.Syntax.Footnote);
  var footnoteParagraph = parseBlockArg(_mapping.Syntax.Paragraph, block.args[1], block.chunk.lines[0]);

  if (footnoteParagraph) {
    node.children = [footnoteParagraph];
  }

  return node;
}
/**
 * parse raw block.
 * @param {Block} block - Block to parse
 * @return {TxtNode} Raw node
 */


function parseRawBlock(block) {
  return parseBlockWithContent(block, _mapping.Syntax.Raw);
}
/**
 * parse quote block.
 * @param {Block} block - Block to parse
 * @return {TxtNode} BlockQuote node
 */


function parseQuote(block) {
  return parseBlockWithContent(block, _mapping.Syntax.Quote);
}
/**
 * parse comment block.
 * @param {Block} block - Block to parse
 * @return {TxtNode} Comment node
 */


function parseCommentBlock(block) {
  return parseBlockWithContent(block, _mapping.Syntax.Comment);
}
/**
 * parse code block, e.g //list, //emlist, //source etc.
 * @param {Block} block - Block to parse
 * @return {TxtNode} CodeBlock node
 */


function parseCodeBlock(block) {
  var node = (0, _parserUtils.createNodeFromChunk)(block.chunk, _mapping.Syntax.CodeBlock);
  node.value = block.chunk.lines.slice(1, block.chunk.lines.length - 1).filter(function (line) {
    return !line.isComment;
  }).map(function (line) {
    return line.raw;
  }).join('');
  return node;
}
/**
 * parse image block.
 * @param {Block} block - Block to parse
 * @return {TxtNode} Image node
 */


function parseImage(block) {
  return (0, _parserUtils.createNodeFromChunk)(block.chunk, _mapping.Syntax.Image);
}
/**
 * parse lead block.
 * @param {Block} block - Block to parse
 * @return {TxtNode} Block node
 */


function parseLead(block) {
  return parseBlockWithContent(block, _mapping.Syntax.Lead);
}
/**
 * parse various short column block.
 * @param {Block} block - Block to parse
 * @return {TxtNode} Block node
 */


function parseShortColumn(block) {
  return parseBlockWithContent(block, _mapping.Syntax.ShortColumn);
}
/**
 * parse a block with content. which is parsed as paragraphs.
 * @param {Block} block - line to parse
 * @param {string} type - Type of node
 * @return {[TxtNode]} TxtNode
 */


function parseBlockWithContent(block, type) {
  var chunk = block.chunk;
  var node = (0, _parserUtils.createNodeFromChunk)(chunk, type);
  node.children = [];
  var lines = [];

  var flushParagraph = function flushParagraph() {
    if (lines.length > 0) {
      var paragraph = (0, _parserUtils.createNodeFromLinesInChunk)(_mapping.Syntax.Paragraph, lines, chunk);
      paragraph.children = [];
      lines.forEach(function (line) {
        Array.prototype.push.apply(paragraph.children, (0, _inlineParsers.parseLine)(line));
      });
      node.children.push(paragraph);
    }

    lines = [];
  };

  chunk.lines.slice(1, chunk.lines.length - 1).forEach(function (line) {
    if (line.text === '') {
      flushParagraph();
    } else {
      lines.push(line);
    }
  });
  flushParagraph();
  return node;
}
/**
 * parse single argument of a block as a TxtNode
 * @param {string} type - Type of node
 * @param {Arg} blockArg - Arg of a block to parse
 * @param {Line} line - line where Arg exists
 * @return {TxtNode}
 */


function parseBlockArg(type, blockArg, line) {
  var argText = blockArg.value;

  if (!argText) {
    return null;
  }

  var startColumn = blockArg.startColumn;
  var blockArgContext = (0, _parserUtils.contextNeedsUnescapeBrackets)((0, _parserUtils.contextFromLine)(line, startColumn));
  var argNode = (0, _parserUtils.createInlineNode)(type, argText, blockArgContext);
  argNode.children = (0, _inlineParsers.parseText)(argText, blockArgContext);
  return argNode;
}

function supportedBlockCommands() {
  return Object.keys(BlockParsers);
}
//# sourceMappingURL=block-parsers.js.map