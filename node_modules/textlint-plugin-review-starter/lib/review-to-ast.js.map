{"version":3,"sources":["../src/review-to-ast.js"],"names":["parse","text","lines","match","chunks","nodes","forEach","chunk","parser","ChunkParsers","type","node","push","ast","Syntax","Document","raw","range","length","loc","start","line","column","end","children","validateAST","prevNode","enter","slice","firstLine","startsWith","substr","lastLine","endsWith","ex","console","log"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { traverse } from '@textlint/ast-traverse';\nimport { test as testTextlintAST } from '@textlint/ast-tester';\nimport { Syntax } from './mapping';\nimport { parseAsChunks } from './chunker';\nimport { ChunkParsers } from './chunk-parsers';\n\n/**\n * parse text and return ast mapped location info.\n * @param {string} text\n * @return {TxtNode}\n */\nexport function parse(text) {\n  const lines = text.match(/(?:.*\\r?\\n|.+$)/g); // split lines preserving line endings\n  const chunks = parseAsChunks(text);\n  const nodes = [];\n  chunks.forEach(chunk => {\n    const parser = ChunkParsers[chunk.type];\n    const node = parser(chunk);\n    if (node !== null) {\n      nodes.push(node);\n    }\n  });\n\n  const ast = {\n    type: Syntax.Document,\n    raw: text,\n    range: [0, text.length],\n    loc: {\n      start: {\n        line: 1,\n        column: 0,\n      },\n      end: {\n        line: lines.length,\n        column: lines[lines.length - 1].length,\n      },\n    },\n    children: nodes,\n  };\n\n  validateAST(ast, text, lines);\n\n  return ast;\n}\n\nfunction validateAST(ast, text, lines) {\n  testTextlintAST(ast);\n\n  let prevNode = ast;\n  traverse(ast, {\n    enter(node) {\n      try {\n        assert(node.raw === text.slice(node.range[0], node.range[1]));\n\n        if (node.loc.start.line === node.loc.end.line) {\n          // single line\n          const line = lines[node.loc.start.line - 1];\n          assert(node.raw === line.slice(node.loc.start.column, node.loc.end.column));\n        } else {\n          // multi line\n          const firstLine = lines[node.loc.start.line - 1];\n          assert(node.raw.startsWith(firstLine.substr(node.loc.start.column)));\n          const lastLine = lines[node.loc.end.line - 1];\n          assert(node.raw.endsWith(lastLine.substr(0, node.loc.end.column)));\n        }\n      } catch (ex) {\n        console.log('type: %s, line: %s, column: %s',\n                    prevNode.type, prevNode.loc.start.line, prevNode.loc.start.column);\n        console.log('type: %s, line: %s, column: %s',\n                    node.type, node.loc.start.line, node.loc.start.column);\n        throw ex;\n      }\n\n      prevNode = node;\n    },\n  });\n\n}\n"],"file":"review-to-ast.js"}