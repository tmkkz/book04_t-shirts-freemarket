{"version":3,"sources":["../src/chunk-parsers.js"],"names":["ChunkParsers","Paragraph","parseParagraph","Heading","parseHeading","UnorderedList","chunk","parseList","OrderedList","DefinitionList","Block","parseBlock","Comment","parseComment","node","children","lines","forEach","line","Array","prototype","push","apply","length","match","text","depth","label","trim","labelOffset","indexOf","strNode","heading","Syntax","prefixRegex","isComment","itemNode","ListItem","itemText","replace","startColumn","block","name","args","parser","BlockParsers","value","slice","join"],"mappings":"AAAA;AACA;;;;;;;;;;;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;AAKO,IAAMA,YAAY,GAAG;AAC1BC,EAAAA,SAAS,EAAEC,cADe;AAE1BC,EAAAA,OAAO,EAAEC,YAFiB;AAG1BC,EAAAA,aAAa,EAAE,uBAAAC,KAAK;AAAA,WAAIC,SAAS,CAAC,YAAD,EAAeD,KAAf,CAAb;AAAA,GAHM;AAI1BE,EAAAA,WAAW,EAAE,qBAAAF,KAAK;AAAA,WAAIC,SAAS,CAAC,cAAD,EAAiBD,KAAjB,CAAb;AAAA,GAJQ;AAK1BG,EAAAA,cAAc,EAAE,wBAAAH,KAAK;AAAA,WAAIC,SAAS,CAAC,gBAAD,EAAmBD,KAAnB,CAAb;AAAA,GALK;AAM1BI,EAAAA,KAAK,EAAEC,UANmB;AAO1BC,EAAAA,OAAO,EAAEC;AAPiB,CAArB;AAUP;AACA;AACA;AACA;AACA;;;;AACO,SAASX,cAAT,CAAwBI,KAAxB,EAA+B;AACpC,MAAMQ,IAAI,GAAG,sCAAoBR,KAApB,CAAb;AACAQ,EAAAA,IAAI,CAACC,QAAL,GAAgB,EAAhB;AACAT,EAAAA,KAAK,CAACU,KAAN,CAAYC,OAAZ,CAAoB,UAAAC,IAAI,EAAI;AAC1BC,IAAAA,KAAK,CAACC,SAAN,CAAgBC,IAAhB,CAAqBC,KAArB,CAA2BR,IAAI,CAACC,QAAhC,EAA0C,8BAAUG,IAAV,CAA1C;AACD,GAFD;AAGA,SAAOJ,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,SAASV,YAAT,CAAsBE,KAAtB,EAA6B;AAAA;AAAA;;AAClC,gDAAO,iCAAAA,KAAK,mCAAL,CAAMU,KAAN,6BAAYO,MAAZ,0BAAuB,CAA9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,MAAML,IAAI,GAAGZ,KAAK,CAACU,KAAN,CAAY,CAAZ,CAAb;AACA,MAAMQ,KAAK,GAAGN,IAAI,CAACO,IAAL,CAAUD,KAAV,CAAgB,gBAAhB,CAAd,CAHkC,CAGgB;;AAClD,MAAME,KAAK,GAAGF,KAAK,CAAC,CAAD,CAAL,CAASD,MAAvB;AACA,MAAMI,KAAK,GAAGH,KAAK,CAAC,CAAD,CAAL,CAASI,IAAT,EAAd;AACA,MAAMC,WAAW,GAAGX,IAAI,CAACO,IAAL,CAAUK,OAAV,CAAkBH,KAAlB,CAApB;AACA,kDAAO,YAAAE,WAAW,qBAAX,IAAe,CAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,MAAME,OAAO,GAAG,gCAAcJ,KAAd,EAAqB,kCAAgBT,IAAhB,EAAsBW,WAAtB,CAArB,CAAhB;AACA,MAAMG,OAAO,GAAG,qCAAmBC,gBAAO9B,OAA1B,EAAmCe,IAAnC,CAAhB;AACAc,EAAAA,OAAO,CAACN,KAAR,GAAgBA,KAAhB;AACAM,EAAAA,OAAO,CAACL,KAAR,GAAgBA,KAAhB;AACAK,EAAAA,OAAO,CAACjB,QAAR,GAAmB,CAACgB,OAAD,CAAnB;AAEA,SAAOC,OAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,SAASzB,SAAT,CAAmB2B,WAAnB,EAAgC5B,KAAhC,EAAuC;AAC5C,MAAMQ,IAAI,GAAG,sCAAoBR,KAApB,CAAb;AACAQ,EAAAA,IAAI,CAACC,QAAL,GAAgB,EAAhB;AACAT,EAAAA,KAAK,CAACU,KAAN,CAAYC,OAAZ,CAAoB,UAAAC,IAAI,EAAI;AAC1B,QAAIA,IAAI,CAACiB,SAAT,EAAoB;AAClBrB,MAAAA,IAAI,CAACC,QAAL,CAAcM,IAAd,CAAmB,4CAA0BH,IAA1B,CAAnB;AACA;AACD;;AAED,QAAMkB,QAAQ,GAAG,qCAAmBH,gBAAOI,QAA1B,EAAoCnB,IAApC,CAAjB;AACAkB,IAAAA,QAAQ,CAACrB,QAAT,GAAoB,EAApB;AACA,QAAMuB,QAAQ,GAAGpB,IAAI,CAACO,IAAL,CAAUc,OAAV,CAAkBL,WAAlB,EAA+B,EAA/B,CAAjB;AACA,QAAMM,WAAW,GAAGtB,IAAI,CAACO,IAAL,CAAUF,MAAV,GAAmBe,QAAQ,CAACf,MAAhD;AACAJ,IAAAA,KAAK,CAACC,SAAN,CAAgBC,IAAhB,CAAqBC,KAArB,CAA2Bc,QAAQ,CAACrB,QAApC,EAC2B,8BAAUuB,QAAV,EAAoB,kCAAgBpB,IAAhB,EAAsBsB,WAAtB,CAApB,CAD3B;AAGA1B,IAAAA,IAAI,CAACC,QAAL,CAAcM,IAAd,CAAmBe,QAAnB;AACD,GAdD;AAeA,SAAOtB,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,SAASH,UAAT,CAAoBL,KAApB,EAA2B;AAChC,MAAMY,IAAI,GAAGZ,KAAK,CAACU,KAAN,CAAY,CAAZ,CAAb;AACA,MAAMQ,KAAK,GAAGN,IAAI,CAACO,IAAL,CAAUD,KAAV,CAAgB,oBAAhB,CAAd;AACA,MAAMiB,KAAK,GAAG;AACZC,IAAAA,IAAI,EAAElB,KAAK,CAAC,CAAD,CADC;AAEZmB,IAAAA,IAAI,EAAE,iCAAenB,KAAK,CAAC,CAAD,CAApB,EAAyB,IAAIA,KAAK,CAAC,CAAD,CAAL,CAASD,MAAtC,CAFM;AAGZjB,IAAAA,KAAK,EAAEA;AAHK,GAAd;AAKA,MAAMsC,MAAM,GAAGC,2BAAaJ,KAAK,CAACC,IAAnB,CAAf;;AAEA,MAAI,CAACE,MAAL,EAAa;AACX,WAAO,IAAP;AACD;;AAED,SAAOA,MAAM,CAACH,KAAD,CAAb;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,SAAS5B,YAAT,CAAsBP,KAAtB,EAA6B;AAClC;AACA;AACA,MAAIA,KAAK,CAACU,KAAN,CAAYO,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,WAAO,4CAA0BjB,KAAK,CAACU,KAAN,CAAY,CAAZ,CAA1B,CAAP;AACD;;AACD,MAAMF,IAAI,GAAG,sCAAoBR,KAApB,CAAb;AACAQ,EAAAA,IAAI,CAACgC,KAAL,GAAaxC,KAAK,CAACU,KAAN,CAAY+B,KAAZ,CAAkB,CAAlB,EAAoB,CAAC,CAArB,EAAwBC,IAAxB,CAA6B,EAA7B,CAAb;AACA,SAAOlC,IAAP;AACD","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { Syntax } from './mapping';\nimport { BlockParsers } from './block-parsers';\nimport { parseText, parseLine } from './inline-parsers';\nimport {\n  parseBlockArgs, createNodeFromChunk, createNodeFromLine, createCommentNodeFromLine,\n  createStrNode, contextFromLine\n} from './parser-utils';\n\nexport const ChunkParsers = {\n  Paragraph: parseParagraph,\n  Heading: parseHeading,\n  UnorderedList: chunk => parseList(/^\\s+\\*+\\s+/, chunk),\n  OrderedList: chunk => parseList(/^\\s+\\d+\\.\\s+/, chunk),\n  DefinitionList: chunk => parseList(/^(\\s+:\\s+|\\s+)/, chunk),\n  Block: parseBlock,\n  Comment: parseComment,\n};\n\n/**\n * parse paragraph chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode} Paragraph node\n */\nexport function parseParagraph(chunk) {\n  const node = createNodeFromChunk(chunk);\n  node.children = [];\n  chunk.lines.forEach(line => {\n    Array.prototype.push.apply(node.children, parseLine(line));\n  });\n  return node;\n}\n\n/**\n * parse heading chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode} Heading node\n */\nexport function parseHeading(chunk) {\n  assert(chunk.lines.length === 1);\n  const line = chunk.lines[0];\n  const match = line.text.match(/(=+)\\S*\\s*(.*)/);  // \\S* skip [column] and {ch01}\n  const depth = match[1].length;\n  const label = match[2].trim();\n  const labelOffset = line.text.indexOf(label);\n  assert(labelOffset >= 0);\n  const strNode = createStrNode(label, contextFromLine(line, labelOffset));\n  const heading = createNodeFromLine(Syntax.Heading, line);\n  heading.depth = depth;\n  heading.label = label;\n  heading.children = [strNode];\n\n  return heading;\n}\n\n/**\n * parse list chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode} Block node\n */\nexport function parseList(prefixRegex, chunk) {\n  const node = createNodeFromChunk(chunk);\n  node.children = [];\n  chunk.lines.forEach(line => {\n    if (line.isComment) {\n      node.children.push(createCommentNodeFromLine(line));\n      return;\n    }\n\n    const itemNode = createNodeFromLine(Syntax.ListItem, line);\n    itemNode.children = [];\n    const itemText = line.text.replace(prefixRegex, '');\n    const startColumn = line.text.length - itemText.length;\n    Array.prototype.push.apply(itemNode.children,\n                               parseText(itemText, contextFromLine(line, startColumn)));\n\n    node.children.push(itemNode);\n  });\n  return node;\n}\n\n/**\n * parse block chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode} Block node\n */\nexport function parseBlock(chunk) {\n  const line = chunk.lines[0];\n  const match = line.text.match(/^\\/\\/(\\w+)(.*)\\{?$/);\n  const block = {\n    name: match[1],\n    args: parseBlockArgs(match[2], 2 + match[1].length),\n    chunk: chunk,\n  };\n  const parser = BlockParsers[block.name];\n\n  if (!parser) {\n    return null;\n  }\n\n  return parser(block);\n}\n\n/**\n * parse comment chunk.\n * @param {Chunk} chunk - Chunk to parse\n * @return {TxtNode}  node\n */\nexport function parseComment(chunk) {\n  // Re:VIEW Starter can block comments\n  //assert(chunk.lines.length === 1);\n  if( chunk.lines.length === 1) {\n    return createCommentNodeFromLine(chunk.lines[0]);\n  }\n  const node = createNodeFromChunk(chunk);\n  node.value = chunk.lines.slice(1,-1).join('');\n  return node;\n}\n"],"file":"chunk-parsers.js"}