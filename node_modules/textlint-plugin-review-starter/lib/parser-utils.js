// LICENSE : MIT
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contextFromLine = contextFromLine;
exports.contextNeedsUnescapeBraces = contextNeedsUnescapeBraces;
exports.contextNeedsUnescapeBrackets = contextNeedsUnescapeBrackets;
exports.createCommentNodeFromLine = createCommentNodeFromLine;
exports.createInlineNode = createInlineNode;
exports.createNodeFromChunk = createNodeFromChunk;
exports.createNodeFromLine = createNodeFromLine;
exports.createNodeFromLinesInChunk = createNodeFromLinesInChunk;
exports.createStrNode = createStrNode;
exports.findInlineTag = findInlineTag;
exports.offsetContext = offsetContext;
exports.parseBlockArgs = parseBlockArgs;
exports.unescapeValue = unescapeValue;

var _assert = _interopRequireDefault(require("assert"));

var _mapping = require("./mapping");

var _powerAssertVisitorKeys = "{\"ArrayExpression\":[\"elements\"],\"AssignmentExpression\":[\"left\",\"right\"],\"BinaryExpression\":[\"left\",\"right\"],\"InterpreterDirective\":[],\"Directive\":[\"value\"],\"DirectiveLiteral\":[],\"BlockStatement\":[\"directives\",\"body\"],\"BreakStatement\":[\"label\"],\"CallExpression\":[\"callee\",\"arguments\",\"typeParameters\",\"typeArguments\"],\"CatchClause\":[\"param\",\"body\"],\"ConditionalExpression\":[\"test\",\"consequent\",\"alternate\"],\"ContinueStatement\":[\"label\"],\"DebuggerStatement\":[],\"DoWhileStatement\":[\"test\",\"body\"],\"EmptyStatement\":[],\"ExpressionStatement\":[\"expression\"],\"File\":[\"program\"],\"ForInStatement\":[\"left\",\"right\",\"body\"],\"ForStatement\":[\"init\",\"test\",\"update\",\"body\"],\"FunctionDeclaration\":[\"id\",\"params\",\"body\",\"returnType\",\"typeParameters\"],\"FunctionExpression\":[\"id\",\"params\",\"body\",\"returnType\",\"typeParameters\"],\"Identifier\":[\"typeAnnotation\",\"decorators\"],\"IfStatement\":[\"test\",\"consequent\",\"alternate\"],\"LabeledStatement\":[\"label\",\"body\"],\"StringLiteral\":[],\"NumericLiteral\":[],\"NullLiteral\":[],\"BooleanLiteral\":[],\"RegExpLiteral\":[],\"LogicalExpression\":[\"left\",\"right\"],\"MemberExpression\":[\"object\",\"property\"],\"NewExpression\":[\"callee\",\"arguments\",\"typeParameters\",\"typeArguments\"],\"Program\":[\"directives\",\"body\"],\"ObjectExpression\":[\"properties\"],\"ObjectMethod\":[\"key\",\"params\",\"body\",\"decorators\",\"returnType\",\"typeParameters\"],\"ObjectProperty\":[\"key\",\"value\",\"decorators\"],\"RestElement\":[\"argument\",\"typeAnnotation\"],\"ReturnStatement\":[\"argument\"],\"SequenceExpression\":[\"expressions\"],\"ParenthesizedExpression\":[\"expression\"],\"SwitchCase\":[\"test\",\"consequent\"],\"SwitchStatement\":[\"discriminant\",\"cases\"],\"ThisExpression\":[],\"ThrowStatement\":[\"argument\"],\"TryStatement\":[\"block\",\"handler\",\"finalizer\"],\"UnaryExpression\":[\"argument\"],\"UpdateExpression\":[\"argument\"],\"VariableDeclaration\":[\"declarations\"],\"VariableDeclarator\":[\"id\",\"init\"],\"WhileStatement\":[\"test\",\"body\"],\"WithStatement\":[\"object\",\"body\"],\"AssignmentPattern\":[\"left\",\"right\",\"decorators\"],\"ArrayPattern\":[\"elements\",\"typeAnnotation\"],\"ArrowFunctionExpression\":[\"params\",\"body\",\"returnType\",\"typeParameters\"],\"ClassBody\":[\"body\"],\"ClassExpression\":[\"id\",\"body\",\"superClass\",\"mixins\",\"typeParameters\",\"superTypeParameters\",\"implements\",\"decorators\"],\"ClassDeclaration\":[\"id\",\"body\",\"superClass\",\"mixins\",\"typeParameters\",\"superTypeParameters\",\"implements\",\"decorators\"],\"ExportAllDeclaration\":[\"source\"],\"ExportDefaultDeclaration\":[\"declaration\"],\"ExportNamedDeclaration\":[\"declaration\",\"specifiers\",\"source\"],\"ExportSpecifier\":[\"local\",\"exported\"],\"ForOfStatement\":[\"left\",\"right\",\"body\"],\"ImportDeclaration\":[\"specifiers\",\"source\"],\"ImportDefaultSpecifier\":[\"local\"],\"ImportNamespaceSpecifier\":[\"local\"],\"ImportSpecifier\":[\"local\",\"imported\"],\"MetaProperty\":[\"meta\",\"property\"],\"ClassMethod\":[\"key\",\"params\",\"body\",\"decorators\",\"returnType\",\"typeParameters\"],\"ObjectPattern\":[\"properties\",\"typeAnnotation\",\"decorators\"],\"SpreadElement\":[\"argument\"],\"Super\":[],\"TaggedTemplateExpression\":[\"tag\",\"quasi\",\"typeParameters\"],\"TemplateElement\":[],\"TemplateLiteral\":[\"quasis\",\"expressions\"],\"YieldExpression\":[\"argument\"],\"AwaitExpression\":[\"argument\"],\"Import\":[],\"BigIntLiteral\":[],\"ExportNamespaceSpecifier\":[\"exported\"],\"OptionalMemberExpression\":[\"object\",\"property\"],\"OptionalCallExpression\":[\"callee\",\"arguments\",\"typeParameters\",\"typeArguments\"],\"ClassProperty\":[\"key\",\"value\",\"typeAnnotation\",\"decorators\"],\"ClassPrivateProperty\":[\"key\",\"value\",\"decorators\",\"typeAnnotation\"],\"ClassPrivateMethod\":[\"key\",\"params\",\"body\",\"decorators\",\"returnType\",\"typeParameters\"],\"PrivateName\":[\"id\"],\"AnyTypeAnnotation\":[],\"ArrayTypeAnnotation\":[\"elementType\"],\"BooleanTypeAnnotation\":[],\"BooleanLiteralTypeAnnotation\":[],\"NullLiteralTypeAnnotation\":[],\"ClassImplements\":[\"id\",\"typeParameters\"],\"DeclareClass\":[\"id\",\"typeParameters\",\"extends\",\"mixins\",\"implements\",\"body\"],\"DeclareFunction\":[\"id\"],\"DeclareInterface\":[\"id\",\"typeParameters\",\"extends\",\"mixins\",\"implements\",\"body\"],\"DeclareModule\":[\"id\",\"body\"],\"DeclareModuleExports\":[\"typeAnnotation\"],\"DeclareTypeAlias\":[\"id\",\"typeParameters\",\"right\"],\"DeclareOpaqueType\":[\"id\",\"typeParameters\",\"supertype\"],\"DeclareVariable\":[\"id\"],\"DeclareExportDeclaration\":[\"declaration\",\"specifiers\",\"source\"],\"DeclareExportAllDeclaration\":[\"source\"],\"DeclaredPredicate\":[\"value\"],\"ExistsTypeAnnotation\":[],\"FunctionTypeAnnotation\":[\"typeParameters\",\"params\",\"rest\",\"returnType\"],\"FunctionTypeParam\":[\"name\",\"typeAnnotation\"],\"GenericTypeAnnotation\":[\"id\",\"typeParameters\"],\"InferredPredicate\":[],\"InterfaceExtends\":[\"id\",\"typeParameters\"],\"InterfaceDeclaration\":[\"id\",\"typeParameters\",\"extends\",\"mixins\",\"implements\",\"body\"],\"InterfaceTypeAnnotation\":[\"extends\",\"body\"],\"IntersectionTypeAnnotation\":[\"types\"],\"MixedTypeAnnotation\":[],\"EmptyTypeAnnotation\":[],\"NullableTypeAnnotation\":[\"typeAnnotation\"],\"NumberLiteralTypeAnnotation\":[],\"NumberTypeAnnotation\":[],\"ObjectTypeAnnotation\":[\"properties\",\"indexers\",\"callProperties\",\"internalSlots\"],\"ObjectTypeInternalSlot\":[\"id\",\"value\",\"optional\",\"static\",\"method\"],\"ObjectTypeCallProperty\":[\"value\"],\"ObjectTypeIndexer\":[\"id\",\"key\",\"value\",\"variance\"],\"ObjectTypeProperty\":[\"key\",\"value\",\"variance\"],\"ObjectTypeSpreadProperty\":[\"argument\"],\"OpaqueType\":[\"id\",\"typeParameters\",\"supertype\",\"impltype\"],\"QualifiedTypeIdentifier\":[\"id\",\"qualification\"],\"StringLiteralTypeAnnotation\":[],\"StringTypeAnnotation\":[],\"SymbolTypeAnnotation\":[],\"ThisTypeAnnotation\":[],\"TupleTypeAnnotation\":[\"types\"],\"TypeofTypeAnnotation\":[\"argument\"],\"TypeAlias\":[\"id\",\"typeParameters\",\"right\"],\"TypeAnnotation\":[\"typeAnnotation\"],\"TypeCastExpression\":[\"expression\",\"typeAnnotation\"],\"TypeParameter\":[\"bound\",\"default\",\"variance\"],\"TypeParameterDeclaration\":[\"params\"],\"TypeParameterInstantiation\":[\"params\"],\"UnionTypeAnnotation\":[\"types\"],\"Variance\":[],\"VoidTypeAnnotation\":[],\"EnumDeclaration\":[\"id\",\"body\"],\"EnumBooleanBody\":[\"members\"],\"EnumNumberBody\":[\"members\"],\"EnumStringBody\":[\"members\"],\"EnumSymbolBody\":[\"members\"],\"EnumBooleanMember\":[\"id\"],\"EnumNumberMember\":[\"id\",\"init\"],\"EnumStringMember\":[\"id\",\"init\"],\"EnumDefaultedMember\":[\"id\"],\"IndexedAccessType\":[\"objectType\",\"indexType\"],\"OptionalIndexedAccessType\":[\"objectType\",\"indexType\"],\"JSXAttribute\":[\"name\",\"value\"],\"JSXClosingElement\":[\"name\"],\"JSXElement\":[\"openingElement\",\"children\",\"closingElement\"],\"JSXEmptyExpression\":[],\"JSXExpressionContainer\":[\"expression\"],\"JSXSpreadChild\":[\"expression\"],\"JSXIdentifier\":[],\"JSXMemberExpression\":[\"object\",\"property\"],\"JSXNamespacedName\":[\"namespace\",\"name\"],\"JSXOpeningElement\":[\"name\",\"attributes\"],\"JSXSpreadAttribute\":[\"argument\"],\"JSXText\":[],\"JSXFragment\":[\"openingFragment\",\"children\",\"closingFragment\"],\"JSXOpeningFragment\":[],\"JSXClosingFragment\":[],\"Noop\":[],\"Placeholder\":[],\"V8IntrinsicIdentifier\":[],\"ArgumentPlaceholder\":[],\"BindExpression\":[\"object\",\"callee\"],\"ImportAttribute\":[\"key\",\"value\"],\"Decorator\":[\"expression\"],\"DoExpression\":[\"body\"],\"ExportDefaultSpecifier\":[\"exported\"],\"RecordExpression\":[\"properties\"],\"TupleExpression\":[\"elements\"],\"DecimalLiteral\":[],\"StaticBlock\":[\"body\"],\"ModuleExpression\":[\"body\"],\"TopicReference\":[],\"PipelineTopicExpression\":[\"expression\"],\"PipelineBareFunction\":[\"callee\"],\"PipelinePrimaryTopicReference\":[],\"TSParameterProperty\":[\"parameter\"],\"TSDeclareFunction\":[\"id\",\"typeParameters\",\"params\",\"returnType\"],\"TSDeclareMethod\":[\"decorators\",\"key\",\"typeParameters\",\"params\",\"returnType\"],\"TSQualifiedName\":[\"left\",\"right\"],\"TSCallSignatureDeclaration\":[\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSConstructSignatureDeclaration\":[\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSPropertySignature\":[\"key\",\"typeAnnotation\",\"initializer\"],\"TSMethodSignature\":[\"key\",\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSIndexSignature\":[\"parameters\",\"typeAnnotation\"],\"TSAnyKeyword\":[],\"TSBooleanKeyword\":[],\"TSBigIntKeyword\":[],\"TSIntrinsicKeyword\":[],\"TSNeverKeyword\":[],\"TSNullKeyword\":[],\"TSNumberKeyword\":[],\"TSObjectKeyword\":[],\"TSStringKeyword\":[],\"TSSymbolKeyword\":[],\"TSUndefinedKeyword\":[],\"TSUnknownKeyword\":[],\"TSVoidKeyword\":[],\"TSThisType\":[],\"TSFunctionType\":[\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSConstructorType\":[\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSTypeReference\":[\"typeName\",\"typeParameters\"],\"TSTypePredicate\":[\"parameterName\",\"typeAnnotation\"],\"TSTypeQuery\":[\"exprName\"],\"TSTypeLiteral\":[\"members\"],\"TSArrayType\":[\"elementType\"],\"TSTupleType\":[\"elementTypes\"],\"TSOptionalType\":[\"typeAnnotation\"],\"TSRestType\":[\"typeAnnotation\"],\"TSNamedTupleMember\":[\"label\",\"elementType\"],\"TSUnionType\":[\"types\"],\"TSIntersectionType\":[\"types\"],\"TSConditionalType\":[\"checkType\",\"extendsType\",\"trueType\",\"falseType\"],\"TSInferType\":[\"typeParameter\"],\"TSParenthesizedType\":[\"typeAnnotation\"],\"TSTypeOperator\":[\"typeAnnotation\"],\"TSIndexedAccessType\":[\"objectType\",\"indexType\"],\"TSMappedType\":[\"typeParameter\",\"typeAnnotation\",\"nameType\"],\"TSLiteralType\":[\"literal\"],\"TSExpressionWithTypeArguments\":[\"expression\",\"typeParameters\"],\"TSInterfaceDeclaration\":[\"id\",\"typeParameters\",\"extends\",\"body\"],\"TSInterfaceBody\":[\"body\"],\"TSTypeAliasDeclaration\":[\"id\",\"typeParameters\",\"typeAnnotation\"],\"TSAsExpression\":[\"expression\",\"typeAnnotation\"],\"TSTypeAssertion\":[\"typeAnnotation\",\"expression\"],\"TSEnumDeclaration\":[\"id\",\"members\"],\"TSEnumMember\":[\"id\",\"initializer\"],\"TSModuleDeclaration\":[\"id\",\"body\"],\"TSModuleBlock\":[\"body\"],\"TSImportType\":[\"argument\",\"qualifier\",\"typeParameters\"],\"TSImportEqualsDeclaration\":[\"id\",\"moduleReference\"],\"TSExternalModuleReference\":[\"expression\"],\"TSNonNullExpression\":[\"expression\"],\"TSExportAssignment\":[\"expression\"],\"TSNamespaceExportDeclaration\":[\"id\"],\"TSTypeAnnotation\":[\"typeAnnotation\"],\"TSTypeParameterInstantiation\":[\"params\"],\"TSTypeParameterDeclaration\":[\"params\"],\"TSTypeParameter\":[\"constraint\",\"default\"]}",
    _powerAssertRecorder = function () { function PowerAssertRecorder() { this.captured = []; } PowerAssertRecorder.prototype._capt = function _capt(value, espath) { this.captured.push({ value: value, espath: espath }); return value; }; PowerAssertRecorder.prototype._expr = function _expr(value, source) { var capturedValues = this.captured; this.captured = []; return { powerAssertContext: { value: value, events: capturedValues }, source: source }; }; return PowerAssertRecorder; }();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * parse arguments of a block like "[foo][This is foo]".
 * @param {string} argsText - String to parse
 * @param {number} offset - Offset index where the args starts with in the line
 * @return {[Arg]} Array of Args
 */
function parseBlockArgs(argsText, offset) {
  var argRegex = /\[(.*?)\]/g;
  var args = [];
  var openIndex = 0;

  while (argsText[openIndex] === '[') {
    var closeIndex = findCloseBracket(argsText, ']', openIndex);
    args.push({
      value: argsText.slice(openIndex + 1, closeIndex),
      startColumn: offset + openIndex + 1
    });
    openIndex = closeIndex + 1;
  }

  return args;
}

function getCloseBracket(character) {
  if (character == '{') {
    return '}';
  }

  return character;
}
/**
 * find inline tag from text
 * @param {string} text - Text to parse
 * @return {Tag} the first Tag object if inline tag found, otherwise null
 */


function findInlineTag(text) {
  // const match = text.match(/@<(#{\w})>(?:(\$)|(?:({)|(\|)))((?:.*@<\w*>[\|${].*?[\|$}].*?|.*?)*)(?(1)(\$)|(?(2)(})|(\|)))/);
  // const match = text.match(/@<(\w+)>\{/);
  var match = text.match(/@<(\w+)>([\{\|\$])/);

  if (!match) {
    return null; // inline tag not found
  } // We need to ignore escaped closing brace \}.
  // As look-behind expression is relatively new, use indexOf()


  var contentStartIndex = match.index + match[0].length;
  var bracket = match[2];
  var closeIndex = findCloseBracket(text, getCloseBracket(bracket), contentStartIndex);

  if (closeIndex < 0) {
    return null; // not found
  }

  var nest = findInlineTag(text.substr(contentStartIndex));

  if (nest) {
    if (contentStartIndex + nest.content.startIndex < closeIndex) {
      closeIndex = findCloseBracket(text, getCloseBracket(bracket), contentStartIndex + nest.content.closeIndex + 1);

      if (closeIndex < 0) {
        return null; // not found
      }
    }
  }

  var contentCloseIndex = closeIndex - 1;
  var rawContent = text.substr(contentStartIndex, contentCloseIndex - contentStartIndex + 1);
  var tag = {
    name: match[1],
    content: {
      raw: rawContent,
      startIndex: contentStartIndex,
      closeIndex: closeIndex,
      index: match[0].length
    },
    fullText: text.substr(match.index, closeIndex - match.index + 1),
    precedingText: text.substr(0, match.index),
    followingText: text.substr(closeIndex + 1)
  };
  return tag;
}

function findCloseBracket(text, character) {
  var fromIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var closeIndex;

  while (true) {
    closeIndex = text.indexOf(character, fromIndex);

    if (closeIndex < 0) {
      break; // closing } not found. this is normal string not a inline tag
    }

    if (text[closeIndex - 1] !== '\\') {
      break; // found closing } which is not escaped
    }

    fromIndex = closeIndex + 1;
  }

  return closeIndex;
}
/**
 * create TxtNode from chunk.
 * @param {Chunk} chunk - A chunk
 * @param {string} [type=chunk.type] - Type of node
 * @return {TxtNode} Created TxtNode
 */


function createNodeFromChunk(chunk, type) {
  type = type || _mapping.Syntax[chunk.type];
  return createNodeFromLinesInChunk(type, chunk.lines, chunk);
}
/**
 * create TxtNode from lines in a chunk.
 * @param {string} type - Type of node
 * @param {[Line]} lines - lines in a chunk
 * @param {Chunk} chunk - A chunk
 * @return {TxtNode} Created TxtNode
 */


function createNodeFromLinesInChunk(type, lines, chunk) {
  var firstLine = lines[0];
  var lastLine = lines[lines.length - 1];
  var chunkStartIndex = chunk.lines[0].startIndex;
  var startIndex = firstLine.startIndex;
  var endIndex = lastLine.startIndex + lastLine.text.length;
  var text = chunk.raw.slice(startIndex - chunkStartIndex, endIndex - chunkStartIndex);
  return {
    type: type,
    raw: text,
    range: [startIndex, endIndex],
    loc: {
      start: {
        line: firstLine.lineNumber,
        column: 0
      },
      end: {
        line: lastLine.lineNumber,
        column: lastLine.text.length
      }
    }
  };
}
/**
 * create TxtNode from single line.
 * @param {Line} line - A line
 * @param {string} type - Type of node
 * @return {TxtNode} Created TxtNode
 */


function createNodeFromLine(type, line) {
  var _rec = new _powerAssertRecorder();

  (0, _assert["default"])(_rec._expr(_rec._capt(!_rec._capt(_rec._capt(line, "arguments/0/argument/object").isComment, "arguments/0/argument"), "arguments/0"), {
    content: "assert(!line.isComment)",
    filepath: "src/parser-utils.js",
    line: 155,
    ast: "{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"assert\",\"range\":[0,6]},\"arguments\":[{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"line\",\"range\":[8,12]},\"property\":{\"type\":\"Identifier\",\"name\":\"isComment\",\"range\":[13,22]},\"computed\":false,\"range\":[8,22]},\"prefix\":true,\"range\":[7,22]}],\"range\":[0,23]}",
    tokens: "[{\"type\":{\"label\":\"name\"},\"value\":\"assert\",\"range\":[0,6]},{\"type\":{\"label\":\"(\"},\"range\":[6,7]},{\"type\":{\"label\":\"!\"},\"value\":\"!\",\"range\":[7,8]},{\"type\":{\"label\":\"name\"},\"value\":\"line\",\"range\":[8,12]},{\"type\":{\"label\":\".\"},\"range\":[12,13]},{\"type\":{\"label\":\"name\"},\"value\":\"isComment\",\"range\":[13,22]},{\"type\":{\"label\":\")\"},\"range\":[22,23]}]",
    visitorKeys: _powerAssertVisitorKeys
  }));
  return createInlineNode(type, line.text, contextFromLine(line));
}
/**
 * create comment TxtNode from single line.
 * @param {Line} line - A line
 * @return {TxtNode} Created TxtNode
 */


function createCommentNodeFromLine(line) {
  var _rec2 = new _powerAssertRecorder();

  (0, _assert["default"])(_rec2._expr(_rec2._capt(_rec2._capt(line, "arguments/0/object").isComment, "arguments/0"), {
    content: "assert(line.isComment)",
    filepath: "src/parser-utils.js",
    line: 165,
    ast: "{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"assert\",\"range\":[0,6]},\"arguments\":[{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"line\",\"range\":[7,11]},\"property\":{\"type\":\"Identifier\",\"name\":\"isComment\",\"range\":[12,21]},\"computed\":false,\"range\":[7,21]}],\"range\":[0,22]}",
    tokens: "[{\"type\":{\"label\":\"name\"},\"value\":\"assert\",\"range\":[0,6]},{\"type\":{\"label\":\"(\"},\"range\":[6,7]},{\"type\":{\"label\":\"name\"},\"value\":\"line\",\"range\":[7,11]},{\"type\":{\"label\":\".\"},\"range\":[11,12]},{\"type\":{\"label\":\"name\"},\"value\":\"isComment\",\"range\":[12,21]},{\"type\":{\"label\":\")\"},\"range\":[21,22]}]",
    visitorKeys: _powerAssertVisitorKeys
  }));
  var node = createInlineNode(_mapping.Syntax.Comment, line.text, contextFromLine(line));
  var match;

  if (match = line.text.match(/^#@#\s*(.*)/)) {
    node.value = match[1];
  } else if (match = line.text.match(/^#@warn\((.*)\)/)) {
    node.value = match[1];
  } else {
    node.value = line.text;
  }

  return node;
}
/**
 * create Str TxtNode.
 * @param {string} raw - Raw text of node
 * @param {Context} context - context of the node
 * @return {TxtNode} Created TxtNode
 */


function createStrNode(raw, context) {
  var node = createInlineNode(_mapping.Syntax.Str, raw, context);
  node.value = unescapeValue(raw, context);
  return node;
}
/**
 * unescape value considering context
 * @param {string} value - Value to unescape
 * @param {Context} context - context of unescape
 * @return {string} Unescaped value
 */


function unescapeValue(value, context) {
  if (context.unescapeBraces) {
    value = value.replace(/\\\}/g, '}');
  }

  if (context.unescapeBrackets) {
    value = value.replace(/\\\]/g, ']');
  }

  return value;
}
/**
 * create inline TxtNode.
 * @param {string} type - Type of node
 * @param {string} raw - Raw text of node
 * @param {Context} context - context of the node
 * @return {TxtNode} Created TxtNode
 */


function createInlineNode(type, raw, context) {
  var _rec3 = new _powerAssertRecorder();

  (0, _assert["default"])(_rec3._expr(_rec3._capt(!_rec3._capt(_rec3._capt(raw, "arguments/0/argument/callee/object").match(/[\r\n]/), "arguments/0/argument"), "arguments/0"), {
    content: "assert(!raw.match(/[\\r\\n]/))",
    filepath: "src/parser-utils.js",
    line: 217,
    ast: "{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"assert\",\"range\":[0,6]},\"arguments\":[{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"raw\",\"range\":[8,11]},\"property\":{\"type\":\"Identifier\",\"name\":\"match\",\"range\":[12,17]},\"computed\":false,\"range\":[8,17]},\"arguments\":[{\"type\":\"RegExpLiteral\",\"pattern\":\"[\\\\r\\\\n]\",\"flags\":\"\",\"range\":[18,26]}],\"range\":[8,27]},\"prefix\":true,\"range\":[7,27]}],\"range\":[0,28]}",
    tokens: "[{\"type\":{\"label\":\"name\"},\"value\":\"assert\",\"range\":[0,6]},{\"type\":{\"label\":\"(\"},\"range\":[6,7]},{\"type\":{\"label\":\"!\"},\"value\":\"!\",\"range\":[7,8]},{\"type\":{\"label\":\"name\"},\"value\":\"raw\",\"range\":[8,11]},{\"type\":{\"label\":\".\"},\"range\":[11,12]},{\"type\":{\"label\":\"name\"},\"value\":\"match\",\"range\":[12,17]},{\"type\":{\"label\":\"(\"},\"range\":[17,18]},{\"type\":{\"label\":\"regexp\"},\"value\":{\"pattern\":\"[\\\\r\\\\n]\",\"flags\":\"\"},\"range\":[18,26]},{\"type\":{\"label\":\")\"},\"range\":[26,27]},{\"type\":{\"label\":\")\"},\"range\":[27,28]}]",
    visitorKeys: _powerAssertVisitorKeys
  }));
  return {
    type: type,
    raw: raw,
    range: [context.startIndex, context.startIndex + raw.length],
    loc: {
      start: {
        line: context.lineNumber,
        column: context.startColumn
      },
      end: {
        line: context.lineNumber,
        column: context.startColumn + raw.length
      }
    }
  };
}
/**
 * create context from Line.
 * @param {Line} line - Line object
 * @param {number} [offset=0] - Column offset
 * @return {Context} Created Context object
 */


function contextFromLine(line) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return {
    startIndex: line.startIndex + offset,
    lineNumber: line.lineNumber,
    startColumn: offset
  };
}
/**
 * create new context with offset from original context.
 * @param {Context} originalContext - Original Context object
 * @param {number} offset - Column offset
 * @return {Context} New Context object
 */


function offsetContext(originalContext, offset) {
  var newContext = Object.assign({}, originalContext);
  newContext.startIndex += offset;
  newContext.startColumn += offset;
  return newContext;
}
/**
 * create new context with unescapeBraces = true.
 * @param {Context} originalContext - Original Context object
 * @return {Context} New Context object
 */


function contextNeedsUnescapeBraces(originalContext) {
  var newContext = Object.assign({}, originalContext);
  newContext.unescapeBraces = true;
  return newContext;
}
/**
 * create new context with unescapeBrackets = true.
 * @param {Context} originalContext - Original Context object
 * @return {Context} New Context object
 */


function contextNeedsUnescapeBrackets(originalContext) {
  var newContext = Object.assign({}, originalContext);
  newContext.unescapeBrackets = true;
  return newContext;
}
//# sourceMappingURL=parser-utils.js.map