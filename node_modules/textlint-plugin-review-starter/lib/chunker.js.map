{"version":3,"sources":["../src/chunker.js"],"names":["ChunkTypes","Paragraph","Heading","UnorderedList","OrderedList","DefinitionList","Block","Comment","parseAsChunks","text","lines","match","startIndex","currentChunk","isComment","chunks","reduce","result","currentLine","index","line","raw","replace","lineNumber","parseLine","length","forEach","chunk","firstLineIndex","lastLineIndex","slice","join","startsWith","createChunk","push","type","flushChunk","endsWith","firstLine"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n'use strict';\n\nexport const ChunkTypes = {\n  Paragraph: 'Paragraph',\n  Heading: 'Heading',\n  UnorderedList: 'UnorderedList',\n  OrderedList: 'OrderedList',\n  DefinitionList: 'DefinitionList',\n  Block: 'Block',\n\n  // NOTE: Comment chunk means an independent comment line. Other chunks may include comment lines.\n  Comment: 'Comment',\n};\n\n/**\n * parse text and return array of chunks.\n * @param {string} text\n * @return {[Chunk]}\n */\nexport function parseAsChunks(text) {\n  const lines = text.match(/(?:.*\\r?\\n|.+$)/g); // split lines preserving line endings\n  //console.log(lines);\n  var startIndex = 0;\n  var currentChunk = null;\n  var isComment = false;\n\n  const chunks = lines.reduce(function (result, currentLine, index) {\n    const line = {\n      raw: currentLine, // with line endings\n      text: currentLine.replace(/\\r?\\n$/, ''), // without line endings\n      lineNumber: index + 1,\n      startIndex: startIndex,\n    };\n    parseLine(result, line);\n    startIndex += currentLine.length;\n    return result;\n  }, []);\n\n  chunks.forEach(chunk => {\n    const firstLineIndex = chunk.lines[0].lineNumber - 1;\n    const lastLineIndex = chunk.lines[chunk.lines.length - 1].lineNumber - 1;\n    chunk.raw = lines.slice(firstLineIndex, lastLineIndex + 1).join('');\n  });\n\n  return chunks;\n\n  function parseLine(result, line) {\n    // comment\n    // NOTE: comment does not break current chunk, i.e. a block can contain comments in its body.\n    if (line.text.startsWith('#@')) {\n      line.isComment = true;\n      if (line.text.startsWith('#@+++')) {\n        isComment = true;\n        if (currentChunk == null) {\n          currentChunk = createChunk(ChunkTypes.Comment, line);\n          result.push(currentChunk);\n        }\n      } else if(line.text.startsWith('#@---')) {\n        isComment = false;\n        if (currentChunk && currentChunk.type === ChunkTypes.Comment) {\n          flushChunk(); // end of Comment\n        }\n      } else {\n        if (currentChunk) {\n          currentChunk.lines.push(line);\n        } else {\n          // A comment line corresponds to a Comment chunk.\n          result.push(createChunk(ChunkTypes.Comment, line));\n        }          \n      }\n      return;\n    }\n\n    if( isComment ) {\n      if (currentChunk) {\n        line.isComment = true;\n        currentChunk.lines.push(line);\n        return;\n      }  \n    }\n\n    // block content\n    if (currentChunk && currentChunk.type === ChunkTypes.Block) {\n      currentChunk.lines.push(line);\n      if (line.text.startsWith('//}')) {\n        flushChunk(); // end of block\n      }\n\n      return;\n    }\n\n    // block open\n    if (line.text.match(/^\\/\\/\\w+/)) {\n      flushChunk();\n      const chunk = createChunk(ChunkTypes.Block, line);\n      result.push(chunk);\n      if (line.text.endsWith('{')) {\n        // block with open and end tags, e.g. //list, //emlist, etc.\n        currentChunk = chunk;\n      }\n\n      return;\n    }\n\n    // heading\n    if (line.text.startsWith('=')) {\n      flushChunk();\n      result.push(createChunk(ChunkTypes.Heading, line));\n      return;\n    }\n\n    // unordered list\n    if (line.text.match(/^\\s+\\*+\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.UnorderedList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.UnorderedList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // ordered list\n    if (line.text.match(/^\\s+\\d+\\.\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.OrderedList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.OrderedList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // definition list\n    if (line.text.match(/^\\s*:\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.DefinitionList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.DefinitionList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // continuation line of definition list\n    if (line.text.match(/^\\s+/) &&\n        currentChunk && currentChunk.type === ChunkTypes.DefinitionList) {\n      currentChunk.lines.push(line);\n      return;\n    }\n\n    // empty line\n    if (line.text === '') {\n      flushChunk();\n      return;\n    }\n\n    // normal string\n    if (currentChunk && currentChunk.type === ChunkTypes.Paragraph) {\n      currentChunk.lines.push(line);\n    } else {\n      flushChunk();\n      currentChunk = createChunk(ChunkTypes.Paragraph, line);\n      result.push(currentChunk);\n    }\n  }\n\n  function flushChunk() {\n    currentChunk = null;\n  }\n\n  function createChunk(type, firstLine) {\n    return {\n      type: type,\n      lines: [firstLine],\n    };\n  }\n}\n"],"file":"chunker.js"}