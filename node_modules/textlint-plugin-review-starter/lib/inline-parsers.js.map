{"version":3,"sources":["../src/inline-parsers.js"],"names":["parseLine","line","isComment","parseText","text","InlineParsers","ami","inlineTextTagParser","Syntax","Amikake","b","Bold","balloon","Ballon","bou","Bouten","del","Delete","em","Emphasis","i","Italic","idx","Index","ins","Insert","strong","Strong","tt","Teletype","ttb","TeletypeBold","tti","TeletypeItalic","tcy","TateChuYoko","u","Underline","href","parseHrefTag","kw","parseKeywordTag","ruby","parseRubyTag","bib","inlineNonTextTagParser","Reference","chap","chapref","column","eq","fn","hd","img","list","table","title","w","wb","br","Break","code","withValue","Code","comment","Comment","embed","Raw","hidx","Hide","icon","Icon","m","Math","raw","uchar","UnicodeChar","B","cursor","Cursor","qq","translateWithValue","DoubleQuote","v","term","userinput","UserInput","weak","Weak","small","Small","xsmall","XSmall","xxsmall","XXSmall","large","Large","xlarge","XLarge","xxlarge","XXLarge","file","hlink","noteref","secref","W","foldhere","Marker","nop","Nop","par","termnoidx","LaTeX","inlineSymbolTagParser","TeX","hearts","inlineParser","translateValue","tag","context","node","value","content","type","parseInlineNonTextTag","parseInlineTextTag","fullText","parseSymbolTag","strContext","index","strNode","children","Keyword","pieces","split","word","length","alt","Href","url","label","labelOffset","indexOf","Ruby","rubyBase","rubyText","Symbol","match","parseNestedText","depth","nodes","precedingText","push","parser","name","nestedContext","Object","assign","startIndex","nestedNodes","followingText","supportedInlineCommands","keys"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { Syntax } from './mapping';\nimport {\n  parseBlockArg, findInlineTag, createNodeFromChunk, createCommentNodeFromLine, createStrNode,\n  createInlineNode, contextFromLine, offsetContext, contextNeedsUnescapeBraces, unescapeValue\n} from './parser-utils';\n\n/**\n * parse a line.\n * @param {Line} line - line to parse\n * @return {[TxtNode]} TxtNodes\n */\nexport function parseLine(line) {\n  if (line.isComment) {\n    return [createCommentNodeFromLine(line)];\n  }\n\n  return parseText(line.text, contextFromLine(line));\n}\n\nconst InlineParsers = {\n  // text tags\n  ami:     inlineTextTagParser(Syntax.Amikake),\n  b:       inlineTextTagParser(Syntax.Bold),\n  balloon: inlineTextTagParser(Syntax.Ballon),\n  bou:     inlineTextTagParser(Syntax.Bouten),\n  del:     inlineTextTagParser(Syntax.Delete),\n  em:      inlineTextTagParser(Syntax.Emphasis),\n  i:       inlineTextTagParser(Syntax.Italic),\n  idx:     inlineTextTagParser(Syntax.Index),\n  ins:     inlineTextTagParser(Syntax.Insert),\n  strong:  inlineTextTagParser(Syntax.Strong),\n  tt:      inlineTextTagParser(Syntax.Teletype),\n  ttb:     inlineTextTagParser(Syntax.TeletypeBold),\n  tti:     inlineTextTagParser(Syntax.TeletypeItalic),\n  tcy:     inlineTextTagParser(Syntax.TateChuYoko),\n  u:       inlineTextTagParser(Syntax.Underline),\n\n  // partially text tags\n  href:    parseHrefTag,\n  kw:      parseKeywordTag,\n  ruby:    parseRubyTag,\n\n  // non-text tags (reference)\n  bib:     inlineNonTextTagParser(Syntax.Reference),\n  chap:    inlineNonTextTagParser(Syntax.Reference),\n  chapref: inlineNonTextTagParser(Syntax.Reference),\n  column:  inlineNonTextTagParser(Syntax.Reference),\n  eq:      inlineNonTextTagParser(Syntax.Reference),\n  fn:      inlineNonTextTagParser(Syntax.Reference),\n  hd:      inlineNonTextTagParser(Syntax.Reference),\n  img:     inlineNonTextTagParser(Syntax.Reference),\n  list:    inlineNonTextTagParser(Syntax.Reference),\n  table:   inlineNonTextTagParser(Syntax.Reference),\n  title:   inlineNonTextTagParser(Syntax.Reference),\n  w:       inlineNonTextTagParser(Syntax.Reference),\n  wb:      inlineNonTextTagParser(Syntax.Reference),\n\n  // non-text tags\n  br:      inlineNonTextTagParser(Syntax.Break),\n  code:    withValue(inlineNonTextTagParser(Syntax.Code)),\n  comment: withValue(inlineNonTextTagParser(Syntax.Comment)),\n  embed:   inlineNonTextTagParser(Syntax.Raw),\n  hidx:    inlineNonTextTagParser(Syntax.Hide),\n  icon:    inlineNonTextTagParser(Syntax.Icon),\n  m:       inlineNonTextTagParser(Syntax.Math),\n  raw:     inlineNonTextTagParser(Syntax.Raw),\n  uchar:   inlineNonTextTagParser(Syntax.UnicodeChar),\n\n  // ---------- Starter ----------\n\n  // text tags\n  B:         inlineTextTagParser(Syntax.Strong),\n  cursor:    inlineTextTagParser(Syntax.Cursor),\n  qq:        translateWithValue(inlineTextTagParser(Syntax.DoubleQuote), (v) => { return `\"${v}\"` }),\n  term:      inlineTextTagParser(Syntax.Index),\n  userinput: inlineTextTagParser(Syntax.UserInput),\n  weak:      inlineTextTagParser(Syntax.Weak),\n\n  small:     inlineTextTagParser(Syntax.Small),\n  xsmall:    inlineTextTagParser(Syntax.XSmall),\n  xxsmall:   inlineTextTagParser(Syntax.XXSmall),\n  large:     inlineTextTagParser(Syntax.Large),\n  xlarge:    inlineTextTagParser(Syntax.XLarge),\n  xxlarge:   inlineTextTagParser(Syntax.XXLarge),\n\n  // partially text tags\n  file:      parseKeywordTag,\n  hlink:     parseHrefTag,\n\n  // non-text tags (reference)\n  noteref:   inlineNonTextTagParser(Syntax.Reference),\n  secref:    inlineNonTextTagParser(Syntax.Reference),\n  W:         inlineNonTextTagParser(Syntax.Reference),\n\n  // non-text tags\n  foldhere:  inlineNonTextTagParser(Syntax.Marker),\n  nop:       inlineNonTextTagParser(Syntax.Nop),\n  par:       inlineNonTextTagParser(Syntax.Break),\n  termnoidx: inlineNonTextTagParser(Syntax.Hide),\n\n  // symbols\n  LaTeX:     inlineSymbolTagParser('LaTeX'),\n  TeX:       inlineSymbolTagParser('TeX'),\n  hearts:    inlineSymbolTagParser('❤'),\n};\n\n/**\n * get new inline tag parser to get value attribute.\n * @param {function} inlineParser - Parser function of a inline tag\n * @return {function} parser function\n */\nfunction withValue(inlineParser) {\n  return translateWithValue(inlineParser, (v) => { return v })\n}\n\n/**\n * get new inline tag parser to get value attribute.\n * @param {function} inlineParser - Parser function of a inline tag\n * @return {function} parser function\n */\n function translateWithValue(inlineParser, translateValue) {\n  return (tag, context) => {\n    const node = inlineParser(tag, context);\n    node.value = translateValue(unescapeValue(tag.content.raw, context));\n    return node;\n  };\n}\n\n/**\n * get non-text tag parser function.\n * @param {string} type - type of tag\n * @return {function} parser function\n */\nfunction inlineNonTextTagParser(type) {\n  return (tag, context) =>\n    parseInlineNonTextTag(type, tag, context);\n}\n\n/**\n * get text tag parser function.\n * @param {string} type - type of tag\n * @return {function} parser function\n */\nfunction inlineTextTagParser(type) {\n  return (tag, context) =>\n    parseInlineTextTag(type, tag, context);\n}\n\n/**\n * parse non-text tag, which has no child.\n * @param {string} type - type of tag\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseInlineNonTextTag(type, tag, context) {\n  const node = createInlineNode(type, tag.fullText, context);\n  return node;\n}\n\n/**\n * get text tag parser function.\n * @param {string} type - type of tag\n * @return {function} parser function\n */\nfunction inlineSymbolTagParser(text) {\n  return (tag, context) =>\n    parseSymbolTag(text, tag, context);\n}\n\n/**\n * parse text tag, which has child Str node.\n * @param {string} type - type of tag\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseInlineTextTag(type, tag, context) {\n  const node = createInlineNode(type, tag.fullText, context);\n  const strContext = offsetContext(context, tag.content.index);\n  const strNode = createStrNode(tag.content.raw, strContext);\n  node.children = [strNode];\n  return node;\n}\n\n/**\n * parse @<kw>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseKeywordTag(tag, context) {\n  const node = createInlineNode(Syntax.Keyword, tag.fullText, context);\n\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  const word = pieces[0];\n  if (pieces.length === 2) {\n    node.alt = pieces[1];\n  }\n\n  const strNode = createStrNode(word, offsetContext(context, tag.content.index));\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse @<href>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseHrefTag(tag, context) {\n  const node = createInlineNode(Syntax.Href, tag.fullText, context);\n\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  const url = pieces[0];\n  let label;\n  let labelOffset;\n  if (pieces.length === 2) {\n    label = pieces[1];\n    labelOffset = tag.content.index + tag.content.raw.indexOf(label, url.length);\n    assert(labelOffset >= tag.content.index);\n  } else {\n    label = url;\n    labelOffset = tag.content.index;\n  }\n\n  const strContext = offsetContext(context, labelOffset);\n  const strNode = createStrNode(label, strContext);\n\n  node.url = url;\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse @<ruby>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseRubyTag(tag, context) {\n  const node = createInlineNode(Syntax.Ruby, tag.fullText, context);\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  assert(pieces.length === 2);\n  const rubyBase = pieces[0];\n  const rubyText = pieces[1];\n\n  const strNode = createStrNode(rubyBase, offsetContext(context, tag.content.index));\n\n  node.rubyText = rubyText;\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse @<LaTex>{} tag.\n * @param {string} text - symbol substitute text\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseSymbolTag(text, tag, context) {\n  const node = createInlineNode(Syntax.Symbol, tag.fullText, context);\n  node.value = text;\n  return node;\n}\n\n/**\n * parse inline tags and StrNodes from line.\n * @param {string} text - Text of the line\n * @param {Context} context - context of the node\n * @return {[TxtNode]} TxtNodes in the line\n */\nexport function parseText(text, context) {\n  assert(!text.match(/[\\r\\n]/));\n\n  return parseNestedText(text, context, 0)\n}\n\nexport function parseNestedText(text, context, depth) {\n  const nodes = [];\n  let tag;\n  while (tag = findInlineTag(text)) {\n    if (tag.precedingText !== '') {\n      const node = createStrNode(tag.precedingText, context);\n      nodes.push(node);\n      context = offsetContext(context, node.raw.length);\n    }\n\n    const parser = InlineParsers[tag.name];\n    if (parser) {\n      let nestedContext = Object.assign({}, context);\n      nestedContext = offsetContext(nestedContext, tag.content.startIndex)\n      const nestedNodes = parseNestedText(tag.content.raw, nestedContext, depth + 1)\n      const node = parser(tag, contextNeedsUnescapeBraces(context));\n      if( nestedNodes ) {\n        node.children = nestedNodes\n      }\n      nodes.push(node);\n    }\n    context = offsetContext(context, tag.fullText.length);\n    text = tag.followingText;\n  }\n\n  if (depth > 0 && !nodes.length) {\n    return null;\n  }\n\n  if (text.length) {\n    const node = createStrNode(text, context);\n    nodes.push(node);\n  }\n\n  return nodes;\n}\n\nexport function supportedInlineCommands() {\n  return Object.keys(InlineParsers)\n}\n"],"file":"inline-parsers.js"}