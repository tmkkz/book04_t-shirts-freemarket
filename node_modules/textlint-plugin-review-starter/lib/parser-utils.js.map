{"version":3,"sources":["../src/parser-utils.js"],"names":["parseBlockArgs","argsText","offset","argRegex","args","openIndex","closeIndex","findCloseBracket","push","value","slice","startColumn","getCloseBracket","character","findInlineTag","text","match","contentStartIndex","index","length","bracket","nest","substr","content","startIndex","contentCloseIndex","rawContent","tag","name","raw","fullText","precedingText","followingText","fromIndex","indexOf","createNodeFromChunk","chunk","type","Syntax","createNodeFromLinesInChunk","lines","firstLine","lastLine","chunkStartIndex","endIndex","range","loc","start","line","lineNumber","column","end","createNodeFromLine","isComment","createInlineNode","contextFromLine","createCommentNodeFromLine","node","Comment","createStrNode","context","Str","unescapeValue","unescapeBraces","replace","unescapeBrackets","offsetContext","originalContext","newContext","Object","assign","contextNeedsUnescapeBraces","contextNeedsUnescapeBrackets"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { Syntax } from './mapping';\n\n/**\n * parse arguments of a block like \"[foo][This is foo]\".\n * @param {string} argsText - String to parse\n * @param {number} offset - Offset index where the args starts with in the line\n * @return {[Arg]} Array of Args\n */\nexport function parseBlockArgs(argsText, offset) {\n  const argRegex = /\\[(.*?)\\]/g;\n  const args = [];\n\n  let openIndex = 0;\n  while (argsText[openIndex] === '[') {\n    let closeIndex = findCloseBracket(argsText, ']', openIndex);\n\n    args.push({\n      value: argsText.slice(openIndex + 1, closeIndex),\n      startColumn: offset + openIndex + 1,\n    });\n\n    openIndex = closeIndex + 1;\n  }\n\n  return args;\n}\n\nfunction getCloseBracket(character) {\n  if( character == '{' ) {\n    return '}';\n  }\n  return character;\n}\n\n/**\n * find inline tag from text\n * @param {string} text - Text to parse\n * @return {Tag} the first Tag object if inline tag found, otherwise null\n */\nexport function findInlineTag(text) {\n  // const match = text.match(/@<(#{\\w})>(?:(\\$)|(?:({)|(\\|)))((?:.*@<\\w*>[\\|${].*?[\\|$}].*?|.*?)*)(?(1)(\\$)|(?(2)(})|(\\|)))/);\n  // const match = text.match(/@<(\\w+)>\\{/);\n  const match = text.match(/@<(\\w+)>([\\{\\|\\$])/);\n  if (!match) {\n    return null; // inline tag not found\n  }\n\n  // We need to ignore escaped closing brace \\}.\n  // As look-behind expression is relatively new, use indexOf()\n  let contentStartIndex = match.index + match[0].length;\n  const bracket = match[2];\n  let closeIndex = findCloseBracket(text, getCloseBracket(bracket), contentStartIndex);\n  if (closeIndex < 0) {\n    return null; // not found\n  }\n  const nest = findInlineTag(text.substr(contentStartIndex))\n  if (nest) {\n    if( contentStartIndex + nest.content.startIndex < closeIndex ) {\n      closeIndex = findCloseBracket(text, getCloseBracket(bracket), contentStartIndex + nest.content.closeIndex + 1);\n      if (closeIndex < 0) {\n        return null; // not found\n      }\n    }\n  }\n\n  const contentCloseIndex = closeIndex - 1;\n  const rawContent = text.substr(contentStartIndex, contentCloseIndex - contentStartIndex + 1);\n  const tag = {\n    name: match[1],\n    content: {\n      raw: rawContent,\n      startIndex: contentStartIndex,\n      closeIndex: closeIndex,\n      index: match[0].length,\n    },\n    fullText: text.substr(match.index, closeIndex - match.index + 1),\n    precedingText: text.substr(0, match.index),\n    followingText: text.substr(closeIndex + 1),\n  };\n\n  return tag;\n}\n\nfunction findCloseBracket(text, character, fromIndex=0) {\n  let closeIndex;\n  while (true) {\n    closeIndex = text.indexOf(character, fromIndex);\n    if (closeIndex < 0) {\n      break; // closing } not found. this is normal string not a inline tag\n    }\n\n    if (text[closeIndex - 1] !== '\\\\') {\n      break; // found closing } which is not escaped\n    }\n\n    fromIndex = closeIndex + 1;\n  }\n\n  return closeIndex;\n}\n\n/**\n * create TxtNode from chunk.\n * @param {Chunk} chunk - A chunk\n * @param {string} [type=chunk.type] - Type of node\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromChunk(chunk, type) {\n  type = type || Syntax[chunk.type];\n  return createNodeFromLinesInChunk(type, chunk.lines, chunk);\n}\n\n/**\n * create TxtNode from lines in a chunk.\n * @param {string} type - Type of node\n * @param {[Line]} lines - lines in a chunk\n * @param {Chunk} chunk - A chunk\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromLinesInChunk(type, lines, chunk) {\n  const firstLine = lines[0];\n  const lastLine = lines[lines.length - 1];\n  const chunkStartIndex = chunk.lines[0].startIndex;\n  const startIndex = firstLine.startIndex;\n  const endIndex = lastLine.startIndex + lastLine.text.length;\n  const text = chunk.raw.slice(startIndex - chunkStartIndex, endIndex - chunkStartIndex);\n\n  return {\n    type: type,\n    raw: text,\n    range: [startIndex, endIndex],\n    loc: {\n      start: {\n        line: firstLine.lineNumber,\n        column: 0,\n      },\n      end: {\n        line: lastLine.lineNumber,\n        column: lastLine.text.length,\n      },\n    },\n  };\n}\n\n/**\n * create TxtNode from single line.\n * @param {Line} line - A line\n * @param {string} type - Type of node\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromLine(type, line) {\n  assert(!line.isComment);\n  return createInlineNode(type, line.text, contextFromLine(line));\n}\n\n/**\n * create comment TxtNode from single line.\n * @param {Line} line - A line\n * @return {TxtNode} Created TxtNode\n */\nexport function createCommentNodeFromLine(line) {\n  assert(line.isComment);\n  const node = createInlineNode(Syntax.Comment, line.text, contextFromLine(line));\n  let match;\n  if (match = line.text.match(/^#@#\\s*(.*)/)) {\n    node.value = match[1];\n  } else if (match = line.text.match(/^#@warn\\((.*)\\)/)) {\n    node.value = match[1];\n  } else {\n    node.value = line.text;\n  }\n\n  return node;\n}\n\n/**\n * create Str TxtNode.\n * @param {string} raw - Raw text of node\n * @param {Context} context - context of the node\n * @return {TxtNode} Created TxtNode\n */\nexport function createStrNode(raw, context) {\n  const node = createInlineNode(Syntax.Str, raw, context);\n  node.value = unescapeValue(raw, context);\n  return node;\n}\n\n/**\n * unescape value considering context\n * @param {string} value - Value to unescape\n * @param {Context} context - context of unescape\n * @return {string} Unescaped value\n */\nexport function unescapeValue(value, context) {\n  if (context.unescapeBraces) {\n    value = value.replace(/\\\\\\}/g, '}');\n  }\n\n  if (context.unescapeBrackets) {\n    value = value.replace(/\\\\\\]/g, ']');\n  }\n\n  return value;\n}\n\n/**\n * create inline TxtNode.\n * @param {string} type - Type of node\n * @param {string} raw - Raw text of node\n * @param {Context} context - context of the node\n * @return {TxtNode} Created TxtNode\n */\nexport function createInlineNode(type, raw, context) {\n  assert(!raw.match(/[\\r\\n]/));\n\n  return {\n    type: type,\n    raw: raw,\n    range: [context.startIndex, context.startIndex + raw.length],\n    loc: {\n      start: {\n        line: context.lineNumber,\n        column: context.startColumn,\n      },\n      end: {\n        line: context.lineNumber,\n        column: context.startColumn + raw.length,\n      },\n    },\n  };\n}\n\n/**\n * create context from Line.\n * @param {Line} line - Line object\n * @param {number} [offset=0] - Column offset\n * @return {Context} Created Context object\n */\nexport function contextFromLine(line, offset=0) {\n  return {\n    startIndex: line.startIndex + offset,\n    lineNumber: line.lineNumber,\n    startColumn: offset,\n  };\n}\n\n/**\n * create new context with offset from original context.\n * @param {Context} originalContext - Original Context object\n * @param {number} offset - Column offset\n * @return {Context} New Context object\n */\nexport function offsetContext(originalContext, offset) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.startIndex += offset;\n  newContext.startColumn += offset;\n  return newContext;\n}\n\n/**\n * create new context with unescapeBraces = true.\n * @param {Context} originalContext - Original Context object\n * @return {Context} New Context object\n */\nexport function contextNeedsUnescapeBraces(originalContext) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.unescapeBraces = true;\n  return newContext;\n}\n\n/**\n * create new context with unescapeBrackets = true.\n * @param {Context} originalContext - Original Context object\n * @return {Context} New Context object\n */\nexport function contextNeedsUnescapeBrackets(originalContext) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.unescapeBrackets = true;\n  return newContext;\n}\n"],"file":"parser-utils.js"}