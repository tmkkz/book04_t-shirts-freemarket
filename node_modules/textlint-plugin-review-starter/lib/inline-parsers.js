// LICENSE : MIT
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseLine = parseLine;
exports.parseNestedText = parseNestedText;
exports.parseText = parseText;
exports.supportedInlineCommands = supportedInlineCommands;

var _assert = _interopRequireDefault(require("assert"));

var _mapping = require("./mapping");

var _parserUtils = require("./parser-utils");

var _powerAssertVisitorKeys = "{\"ArrayExpression\":[\"elements\"],\"AssignmentExpression\":[\"left\",\"right\"],\"BinaryExpression\":[\"left\",\"right\"],\"InterpreterDirective\":[],\"Directive\":[\"value\"],\"DirectiveLiteral\":[],\"BlockStatement\":[\"directives\",\"body\"],\"BreakStatement\":[\"label\"],\"CallExpression\":[\"callee\",\"arguments\",\"typeParameters\",\"typeArguments\"],\"CatchClause\":[\"param\",\"body\"],\"ConditionalExpression\":[\"test\",\"consequent\",\"alternate\"],\"ContinueStatement\":[\"label\"],\"DebuggerStatement\":[],\"DoWhileStatement\":[\"test\",\"body\"],\"EmptyStatement\":[],\"ExpressionStatement\":[\"expression\"],\"File\":[\"program\"],\"ForInStatement\":[\"left\",\"right\",\"body\"],\"ForStatement\":[\"init\",\"test\",\"update\",\"body\"],\"FunctionDeclaration\":[\"id\",\"params\",\"body\",\"returnType\",\"typeParameters\"],\"FunctionExpression\":[\"id\",\"params\",\"body\",\"returnType\",\"typeParameters\"],\"Identifier\":[\"typeAnnotation\",\"decorators\"],\"IfStatement\":[\"test\",\"consequent\",\"alternate\"],\"LabeledStatement\":[\"label\",\"body\"],\"StringLiteral\":[],\"NumericLiteral\":[],\"NullLiteral\":[],\"BooleanLiteral\":[],\"RegExpLiteral\":[],\"LogicalExpression\":[\"left\",\"right\"],\"MemberExpression\":[\"object\",\"property\"],\"NewExpression\":[\"callee\",\"arguments\",\"typeParameters\",\"typeArguments\"],\"Program\":[\"directives\",\"body\"],\"ObjectExpression\":[\"properties\"],\"ObjectMethod\":[\"key\",\"params\",\"body\",\"decorators\",\"returnType\",\"typeParameters\"],\"ObjectProperty\":[\"key\",\"value\",\"decorators\"],\"RestElement\":[\"argument\",\"typeAnnotation\"],\"ReturnStatement\":[\"argument\"],\"SequenceExpression\":[\"expressions\"],\"ParenthesizedExpression\":[\"expression\"],\"SwitchCase\":[\"test\",\"consequent\"],\"SwitchStatement\":[\"discriminant\",\"cases\"],\"ThisExpression\":[],\"ThrowStatement\":[\"argument\"],\"TryStatement\":[\"block\",\"handler\",\"finalizer\"],\"UnaryExpression\":[\"argument\"],\"UpdateExpression\":[\"argument\"],\"VariableDeclaration\":[\"declarations\"],\"VariableDeclarator\":[\"id\",\"init\"],\"WhileStatement\":[\"test\",\"body\"],\"WithStatement\":[\"object\",\"body\"],\"AssignmentPattern\":[\"left\",\"right\",\"decorators\"],\"ArrayPattern\":[\"elements\",\"typeAnnotation\"],\"ArrowFunctionExpression\":[\"params\",\"body\",\"returnType\",\"typeParameters\"],\"ClassBody\":[\"body\"],\"ClassExpression\":[\"id\",\"body\",\"superClass\",\"mixins\",\"typeParameters\",\"superTypeParameters\",\"implements\",\"decorators\"],\"ClassDeclaration\":[\"id\",\"body\",\"superClass\",\"mixins\",\"typeParameters\",\"superTypeParameters\",\"implements\",\"decorators\"],\"ExportAllDeclaration\":[\"source\"],\"ExportDefaultDeclaration\":[\"declaration\"],\"ExportNamedDeclaration\":[\"declaration\",\"specifiers\",\"source\"],\"ExportSpecifier\":[\"local\",\"exported\"],\"ForOfStatement\":[\"left\",\"right\",\"body\"],\"ImportDeclaration\":[\"specifiers\",\"source\"],\"ImportDefaultSpecifier\":[\"local\"],\"ImportNamespaceSpecifier\":[\"local\"],\"ImportSpecifier\":[\"local\",\"imported\"],\"MetaProperty\":[\"meta\",\"property\"],\"ClassMethod\":[\"key\",\"params\",\"body\",\"decorators\",\"returnType\",\"typeParameters\"],\"ObjectPattern\":[\"properties\",\"typeAnnotation\",\"decorators\"],\"SpreadElement\":[\"argument\"],\"Super\":[],\"TaggedTemplateExpression\":[\"tag\",\"quasi\",\"typeParameters\"],\"TemplateElement\":[],\"TemplateLiteral\":[\"quasis\",\"expressions\"],\"YieldExpression\":[\"argument\"],\"AwaitExpression\":[\"argument\"],\"Import\":[],\"BigIntLiteral\":[],\"ExportNamespaceSpecifier\":[\"exported\"],\"OptionalMemberExpression\":[\"object\",\"property\"],\"OptionalCallExpression\":[\"callee\",\"arguments\",\"typeParameters\",\"typeArguments\"],\"ClassProperty\":[\"key\",\"value\",\"typeAnnotation\",\"decorators\"],\"ClassPrivateProperty\":[\"key\",\"value\",\"decorators\",\"typeAnnotation\"],\"ClassPrivateMethod\":[\"key\",\"params\",\"body\",\"decorators\",\"returnType\",\"typeParameters\"],\"PrivateName\":[\"id\"],\"AnyTypeAnnotation\":[],\"ArrayTypeAnnotation\":[\"elementType\"],\"BooleanTypeAnnotation\":[],\"BooleanLiteralTypeAnnotation\":[],\"NullLiteralTypeAnnotation\":[],\"ClassImplements\":[\"id\",\"typeParameters\"],\"DeclareClass\":[\"id\",\"typeParameters\",\"extends\",\"mixins\",\"implements\",\"body\"],\"DeclareFunction\":[\"id\"],\"DeclareInterface\":[\"id\",\"typeParameters\",\"extends\",\"mixins\",\"implements\",\"body\"],\"DeclareModule\":[\"id\",\"body\"],\"DeclareModuleExports\":[\"typeAnnotation\"],\"DeclareTypeAlias\":[\"id\",\"typeParameters\",\"right\"],\"DeclareOpaqueType\":[\"id\",\"typeParameters\",\"supertype\"],\"DeclareVariable\":[\"id\"],\"DeclareExportDeclaration\":[\"declaration\",\"specifiers\",\"source\"],\"DeclareExportAllDeclaration\":[\"source\"],\"DeclaredPredicate\":[\"value\"],\"ExistsTypeAnnotation\":[],\"FunctionTypeAnnotation\":[\"typeParameters\",\"params\",\"rest\",\"returnType\"],\"FunctionTypeParam\":[\"name\",\"typeAnnotation\"],\"GenericTypeAnnotation\":[\"id\",\"typeParameters\"],\"InferredPredicate\":[],\"InterfaceExtends\":[\"id\",\"typeParameters\"],\"InterfaceDeclaration\":[\"id\",\"typeParameters\",\"extends\",\"mixins\",\"implements\",\"body\"],\"InterfaceTypeAnnotation\":[\"extends\",\"body\"],\"IntersectionTypeAnnotation\":[\"types\"],\"MixedTypeAnnotation\":[],\"EmptyTypeAnnotation\":[],\"NullableTypeAnnotation\":[\"typeAnnotation\"],\"NumberLiteralTypeAnnotation\":[],\"NumberTypeAnnotation\":[],\"ObjectTypeAnnotation\":[\"properties\",\"indexers\",\"callProperties\",\"internalSlots\"],\"ObjectTypeInternalSlot\":[\"id\",\"value\",\"optional\",\"static\",\"method\"],\"ObjectTypeCallProperty\":[\"value\"],\"ObjectTypeIndexer\":[\"id\",\"key\",\"value\",\"variance\"],\"ObjectTypeProperty\":[\"key\",\"value\",\"variance\"],\"ObjectTypeSpreadProperty\":[\"argument\"],\"OpaqueType\":[\"id\",\"typeParameters\",\"supertype\",\"impltype\"],\"QualifiedTypeIdentifier\":[\"id\",\"qualification\"],\"StringLiteralTypeAnnotation\":[],\"StringTypeAnnotation\":[],\"SymbolTypeAnnotation\":[],\"ThisTypeAnnotation\":[],\"TupleTypeAnnotation\":[\"types\"],\"TypeofTypeAnnotation\":[\"argument\"],\"TypeAlias\":[\"id\",\"typeParameters\",\"right\"],\"TypeAnnotation\":[\"typeAnnotation\"],\"TypeCastExpression\":[\"expression\",\"typeAnnotation\"],\"TypeParameter\":[\"bound\",\"default\",\"variance\"],\"TypeParameterDeclaration\":[\"params\"],\"TypeParameterInstantiation\":[\"params\"],\"UnionTypeAnnotation\":[\"types\"],\"Variance\":[],\"VoidTypeAnnotation\":[],\"EnumDeclaration\":[\"id\",\"body\"],\"EnumBooleanBody\":[\"members\"],\"EnumNumberBody\":[\"members\"],\"EnumStringBody\":[\"members\"],\"EnumSymbolBody\":[\"members\"],\"EnumBooleanMember\":[\"id\"],\"EnumNumberMember\":[\"id\",\"init\"],\"EnumStringMember\":[\"id\",\"init\"],\"EnumDefaultedMember\":[\"id\"],\"IndexedAccessType\":[\"objectType\",\"indexType\"],\"OptionalIndexedAccessType\":[\"objectType\",\"indexType\"],\"JSXAttribute\":[\"name\",\"value\"],\"JSXClosingElement\":[\"name\"],\"JSXElement\":[\"openingElement\",\"children\",\"closingElement\"],\"JSXEmptyExpression\":[],\"JSXExpressionContainer\":[\"expression\"],\"JSXSpreadChild\":[\"expression\"],\"JSXIdentifier\":[],\"JSXMemberExpression\":[\"object\",\"property\"],\"JSXNamespacedName\":[\"namespace\",\"name\"],\"JSXOpeningElement\":[\"name\",\"attributes\"],\"JSXSpreadAttribute\":[\"argument\"],\"JSXText\":[],\"JSXFragment\":[\"openingFragment\",\"children\",\"closingFragment\"],\"JSXOpeningFragment\":[],\"JSXClosingFragment\":[],\"Noop\":[],\"Placeholder\":[],\"V8IntrinsicIdentifier\":[],\"ArgumentPlaceholder\":[],\"BindExpression\":[\"object\",\"callee\"],\"ImportAttribute\":[\"key\",\"value\"],\"Decorator\":[\"expression\"],\"DoExpression\":[\"body\"],\"ExportDefaultSpecifier\":[\"exported\"],\"RecordExpression\":[\"properties\"],\"TupleExpression\":[\"elements\"],\"DecimalLiteral\":[],\"StaticBlock\":[\"body\"],\"ModuleExpression\":[\"body\"],\"TopicReference\":[],\"PipelineTopicExpression\":[\"expression\"],\"PipelineBareFunction\":[\"callee\"],\"PipelinePrimaryTopicReference\":[],\"TSParameterProperty\":[\"parameter\"],\"TSDeclareFunction\":[\"id\",\"typeParameters\",\"params\",\"returnType\"],\"TSDeclareMethod\":[\"decorators\",\"key\",\"typeParameters\",\"params\",\"returnType\"],\"TSQualifiedName\":[\"left\",\"right\"],\"TSCallSignatureDeclaration\":[\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSConstructSignatureDeclaration\":[\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSPropertySignature\":[\"key\",\"typeAnnotation\",\"initializer\"],\"TSMethodSignature\":[\"key\",\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSIndexSignature\":[\"parameters\",\"typeAnnotation\"],\"TSAnyKeyword\":[],\"TSBooleanKeyword\":[],\"TSBigIntKeyword\":[],\"TSIntrinsicKeyword\":[],\"TSNeverKeyword\":[],\"TSNullKeyword\":[],\"TSNumberKeyword\":[],\"TSObjectKeyword\":[],\"TSStringKeyword\":[],\"TSSymbolKeyword\":[],\"TSUndefinedKeyword\":[],\"TSUnknownKeyword\":[],\"TSVoidKeyword\":[],\"TSThisType\":[],\"TSFunctionType\":[\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSConstructorType\":[\"typeParameters\",\"parameters\",\"typeAnnotation\"],\"TSTypeReference\":[\"typeName\",\"typeParameters\"],\"TSTypePredicate\":[\"parameterName\",\"typeAnnotation\"],\"TSTypeQuery\":[\"exprName\"],\"TSTypeLiteral\":[\"members\"],\"TSArrayType\":[\"elementType\"],\"TSTupleType\":[\"elementTypes\"],\"TSOptionalType\":[\"typeAnnotation\"],\"TSRestType\":[\"typeAnnotation\"],\"TSNamedTupleMember\":[\"label\",\"elementType\"],\"TSUnionType\":[\"types\"],\"TSIntersectionType\":[\"types\"],\"TSConditionalType\":[\"checkType\",\"extendsType\",\"trueType\",\"falseType\"],\"TSInferType\":[\"typeParameter\"],\"TSParenthesizedType\":[\"typeAnnotation\"],\"TSTypeOperator\":[\"typeAnnotation\"],\"TSIndexedAccessType\":[\"objectType\",\"indexType\"],\"TSMappedType\":[\"typeParameter\",\"typeAnnotation\",\"nameType\"],\"TSLiteralType\":[\"literal\"],\"TSExpressionWithTypeArguments\":[\"expression\",\"typeParameters\"],\"TSInterfaceDeclaration\":[\"id\",\"typeParameters\",\"extends\",\"body\"],\"TSInterfaceBody\":[\"body\"],\"TSTypeAliasDeclaration\":[\"id\",\"typeParameters\",\"typeAnnotation\"],\"TSAsExpression\":[\"expression\",\"typeAnnotation\"],\"TSTypeAssertion\":[\"typeAnnotation\",\"expression\"],\"TSEnumDeclaration\":[\"id\",\"members\"],\"TSEnumMember\":[\"id\",\"initializer\"],\"TSModuleDeclaration\":[\"id\",\"body\"],\"TSModuleBlock\":[\"body\"],\"TSImportType\":[\"argument\",\"qualifier\",\"typeParameters\"],\"TSImportEqualsDeclaration\":[\"id\",\"moduleReference\"],\"TSExternalModuleReference\":[\"expression\"],\"TSNonNullExpression\":[\"expression\"],\"TSExportAssignment\":[\"expression\"],\"TSNamespaceExportDeclaration\":[\"id\"],\"TSTypeAnnotation\":[\"typeAnnotation\"],\"TSTypeParameterInstantiation\":[\"params\"],\"TSTypeParameterDeclaration\":[\"params\"],\"TSTypeParameter\":[\"constraint\",\"default\"]}",
    _powerAssertRecorder = function () { function PowerAssertRecorder() { this.captured = []; } PowerAssertRecorder.prototype._capt = function _capt(value, espath) { this.captured.push({ value: value, espath: espath }); return value; }; PowerAssertRecorder.prototype._expr = function _expr(value, source) { var capturedValues = this.captured; this.captured = []; return { powerAssertContext: { value: value, events: capturedValues }, source: source }; }; return PowerAssertRecorder; }();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * parse a line.
 * @param {Line} line - line to parse
 * @return {[TxtNode]} TxtNodes
 */
function parseLine(line) {
  if (line.isComment) {
    return [(0, _parserUtils.createCommentNodeFromLine)(line)];
  }

  return parseText(line.text, (0, _parserUtils.contextFromLine)(line));
}

var InlineParsers = {
  // text tags
  ami: inlineTextTagParser(_mapping.Syntax.Amikake),
  b: inlineTextTagParser(_mapping.Syntax.Bold),
  balloon: inlineTextTagParser(_mapping.Syntax.Ballon),
  bou: inlineTextTagParser(_mapping.Syntax.Bouten),
  del: inlineTextTagParser(_mapping.Syntax.Delete),
  em: inlineTextTagParser(_mapping.Syntax.Emphasis),
  i: inlineTextTagParser(_mapping.Syntax.Italic),
  idx: inlineTextTagParser(_mapping.Syntax.Index),
  ins: inlineTextTagParser(_mapping.Syntax.Insert),
  strong: inlineTextTagParser(_mapping.Syntax.Strong),
  tt: inlineTextTagParser(_mapping.Syntax.Teletype),
  ttb: inlineTextTagParser(_mapping.Syntax.TeletypeBold),
  tti: inlineTextTagParser(_mapping.Syntax.TeletypeItalic),
  tcy: inlineTextTagParser(_mapping.Syntax.TateChuYoko),
  u: inlineTextTagParser(_mapping.Syntax.Underline),
  // partially text tags
  href: parseHrefTag,
  kw: parseKeywordTag,
  ruby: parseRubyTag,
  // non-text tags (reference)
  bib: inlineNonTextTagParser(_mapping.Syntax.Reference),
  chap: inlineNonTextTagParser(_mapping.Syntax.Reference),
  chapref: inlineNonTextTagParser(_mapping.Syntax.Reference),
  column: inlineNonTextTagParser(_mapping.Syntax.Reference),
  eq: inlineNonTextTagParser(_mapping.Syntax.Reference),
  fn: inlineNonTextTagParser(_mapping.Syntax.Reference),
  hd: inlineNonTextTagParser(_mapping.Syntax.Reference),
  img: inlineNonTextTagParser(_mapping.Syntax.Reference),
  list: inlineNonTextTagParser(_mapping.Syntax.Reference),
  table: inlineNonTextTagParser(_mapping.Syntax.Reference),
  title: inlineNonTextTagParser(_mapping.Syntax.Reference),
  w: inlineNonTextTagParser(_mapping.Syntax.Reference),
  wb: inlineNonTextTagParser(_mapping.Syntax.Reference),
  // non-text tags
  br: inlineNonTextTagParser(_mapping.Syntax.Break),
  code: withValue(inlineNonTextTagParser(_mapping.Syntax.Code)),
  comment: withValue(inlineNonTextTagParser(_mapping.Syntax.Comment)),
  embed: inlineNonTextTagParser(_mapping.Syntax.Raw),
  hidx: inlineNonTextTagParser(_mapping.Syntax.Hide),
  icon: inlineNonTextTagParser(_mapping.Syntax.Icon),
  m: inlineNonTextTagParser(_mapping.Syntax.Math),
  raw: inlineNonTextTagParser(_mapping.Syntax.Raw),
  uchar: inlineNonTextTagParser(_mapping.Syntax.UnicodeChar),
  // ---------- Starter ----------
  // text tags
  B: inlineTextTagParser(_mapping.Syntax.Strong),
  cursor: inlineTextTagParser(_mapping.Syntax.Cursor),
  qq: translateWithValue(inlineTextTagParser(_mapping.Syntax.DoubleQuote), function (v) {
    return "\"".concat(v, "\"");
  }),
  term: inlineTextTagParser(_mapping.Syntax.Index),
  userinput: inlineTextTagParser(_mapping.Syntax.UserInput),
  weak: inlineTextTagParser(_mapping.Syntax.Weak),
  small: inlineTextTagParser(_mapping.Syntax.Small),
  xsmall: inlineTextTagParser(_mapping.Syntax.XSmall),
  xxsmall: inlineTextTagParser(_mapping.Syntax.XXSmall),
  large: inlineTextTagParser(_mapping.Syntax.Large),
  xlarge: inlineTextTagParser(_mapping.Syntax.XLarge),
  xxlarge: inlineTextTagParser(_mapping.Syntax.XXLarge),
  // partially text tags
  file: parseKeywordTag,
  hlink: parseHrefTag,
  // non-text tags (reference)
  noteref: inlineNonTextTagParser(_mapping.Syntax.Reference),
  secref: inlineNonTextTagParser(_mapping.Syntax.Reference),
  W: inlineNonTextTagParser(_mapping.Syntax.Reference),
  // non-text tags
  foldhere: inlineNonTextTagParser(_mapping.Syntax.Marker),
  nop: inlineNonTextTagParser(_mapping.Syntax.Nop),
  par: inlineNonTextTagParser(_mapping.Syntax.Break),
  termnoidx: inlineNonTextTagParser(_mapping.Syntax.Hide),
  // symbols
  LaTeX: inlineSymbolTagParser('LaTeX'),
  TeX: inlineSymbolTagParser('TeX'),
  hearts: inlineSymbolTagParser('‚ù§')
};
/**
 * get new inline tag parser to get value attribute.
 * @param {function} inlineParser - Parser function of a inline tag
 * @return {function} parser function
 */

function withValue(inlineParser) {
  return translateWithValue(inlineParser, function (v) {
    return v;
  });
}
/**
 * get new inline tag parser to get value attribute.
 * @param {function} inlineParser - Parser function of a inline tag
 * @return {function} parser function
 */


function translateWithValue(inlineParser, translateValue) {
  return function (tag, context) {
    var node = inlineParser(tag, context);
    node.value = translateValue((0, _parserUtils.unescapeValue)(tag.content.raw, context));
    return node;
  };
}
/**
 * get non-text tag parser function.
 * @param {string} type - type of tag
 * @return {function} parser function
 */


function inlineNonTextTagParser(type) {
  return function (tag, context) {
    return parseInlineNonTextTag(type, tag, context);
  };
}
/**
 * get text tag parser function.
 * @param {string} type - type of tag
 * @return {function} parser function
 */


function inlineTextTagParser(type) {
  return function (tag, context) {
    return parseInlineTextTag(type, tag, context);
  };
}
/**
 * parse non-text tag, which has no child.
 * @param {string} type - type of tag
 * @param {Tag} tag - tag to parse
 * @param {Context} context - context of the node
 * @return {TxtNode}
 */


function parseInlineNonTextTag(type, tag, context) {
  var node = (0, _parserUtils.createInlineNode)(type, tag.fullText, context);
  return node;
}
/**
 * get text tag parser function.
 * @param {string} type - type of tag
 * @return {function} parser function
 */


function inlineSymbolTagParser(text) {
  return function (tag, context) {
    return parseSymbolTag(text, tag, context);
  };
}
/**
 * parse text tag, which has child Str node.
 * @param {string} type - type of tag
 * @param {Tag} tag - tag to parse
 * @param {Context} context - context of the node
 * @return {TxtNode}
 */


function parseInlineTextTag(type, tag, context) {
  var node = (0, _parserUtils.createInlineNode)(type, tag.fullText, context);
  var strContext = (0, _parserUtils.offsetContext)(context, tag.content.index);
  var strNode = (0, _parserUtils.createStrNode)(tag.content.raw, strContext);
  node.children = [strNode];
  return node;
}
/**
 * parse @<kw>{} tag.
 * @param {Tag} tag - tag to parse
 * @param {Context} context - context of the node
 * @return {TxtNode}
 */


function parseKeywordTag(tag, context) {
  var node = (0, _parserUtils.createInlineNode)(_mapping.Syntax.Keyword, tag.fullText, context);
  var pieces = tag.content.raw.split(/\s*,\s*/, 2);
  var word = pieces[0];

  if (pieces.length === 2) {
    node.alt = pieces[1];
  }

  var strNode = (0, _parserUtils.createStrNode)(word, (0, _parserUtils.offsetContext)(context, tag.content.index));
  node.children = [strNode];
  return node;
}
/**
 * parse @<href>{} tag.
 * @param {Tag} tag - tag to parse
 * @param {Context} context - context of the node
 * @return {TxtNode}
 */


function parseHrefTag(tag, context) {
  var node = (0, _parserUtils.createInlineNode)(_mapping.Syntax.Href, tag.fullText, context);
  var pieces = tag.content.raw.split(/\s*,\s*/, 2);
  var url = pieces[0];
  var label;
  var labelOffset;

  if (pieces.length === 2) {
    var _rec = new _powerAssertRecorder();

    label = pieces[1];
    labelOffset = tag.content.index + tag.content.raw.indexOf(label, url.length);
    (0, _assert["default"])(_rec._expr(_rec._capt(_rec._capt(labelOffset, "arguments/0/left") >= _rec._capt(_rec._capt(_rec._capt(tag, "arguments/0/right/object/object").content, "arguments/0/right/object").index, "arguments/0/right"), "arguments/0"), {
      content: "assert(labelOffset >= tag.content.index)",
      filepath: "src/inline-parsers.js",
      line: 226,
      ast: "{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"assert\",\"range\":[0,6]},\"arguments\":[{\"type\":\"BinaryExpression\",\"operator\":\">=\",\"left\":{\"type\":\"Identifier\",\"name\":\"labelOffset\",\"range\":[7,18]},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"tag\",\"range\":[22,25]},\"property\":{\"type\":\"Identifier\",\"name\":\"content\",\"range\":[26,33]},\"computed\":false,\"range\":[22,33]},\"property\":{\"type\":\"Identifier\",\"name\":\"index\",\"range\":[34,39]},\"computed\":false,\"range\":[22,39]},\"range\":[7,39]}],\"range\":[0,40]}",
      tokens: "[{\"type\":{\"label\":\"name\"},\"value\":\"assert\",\"range\":[0,6]},{\"type\":{\"label\":\"(\"},\"range\":[6,7]},{\"type\":{\"label\":\"name\"},\"value\":\"labelOffset\",\"range\":[7,18]},{\"type\":{\"label\":\"</>/<=/>=\"},\"value\":\">=\",\"range\":[19,21]},{\"type\":{\"label\":\"name\"},\"value\":\"tag\",\"range\":[22,25]},{\"type\":{\"label\":\".\"},\"range\":[25,26]},{\"type\":{\"label\":\"name\"},\"value\":\"content\",\"range\":[26,33]},{\"type\":{\"label\":\".\"},\"range\":[33,34]},{\"type\":{\"label\":\"name\"},\"value\":\"index\",\"range\":[34,39]},{\"type\":{\"label\":\")\"},\"range\":[39,40]}]",
      visitorKeys: _powerAssertVisitorKeys
    }));
  } else {
    label = url;
    labelOffset = tag.content.index;
  }

  var strContext = (0, _parserUtils.offsetContext)(context, labelOffset);
  var strNode = (0, _parserUtils.createStrNode)(label, strContext);
  node.url = url;
  node.children = [strNode];
  return node;
}
/**
 * parse @<ruby>{} tag.
 * @param {Tag} tag - tag to parse
 * @param {Context} context - context of the node
 * @return {TxtNode}
 */


function parseRubyTag(tag, context) {
  var _rec2 = new _powerAssertRecorder();

  var node = (0, _parserUtils.createInlineNode)(_mapping.Syntax.Ruby, tag.fullText, context);
  var pieces = tag.content.raw.split(/\s*,\s*/, 2);
  (0, _assert["default"])(_rec2._expr(_rec2._capt(_rec2._capt(_rec2._capt(pieces, "arguments/0/left/object").length, "arguments/0/left") === 2, "arguments/0"), {
    content: "assert(pieces.length === 2)",
    filepath: "src/inline-parsers.js",
    line: 250,
    ast: "{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"assert\",\"range\":[0,6]},\"arguments\":[{\"type\":\"BinaryExpression\",\"operator\":\"===\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"pieces\",\"range\":[7,13]},\"property\":{\"type\":\"Identifier\",\"name\":\"length\",\"range\":[14,20]},\"computed\":false,\"range\":[7,20]},\"right\":{\"type\":\"NumericLiteral\",\"value\":2,\"range\":[25,26]},\"range\":[7,26]}],\"range\":[0,27]}",
    tokens: "[{\"type\":{\"label\":\"name\"},\"value\":\"assert\",\"range\":[0,6]},{\"type\":{\"label\":\"(\"},\"range\":[6,7]},{\"type\":{\"label\":\"name\"},\"value\":\"pieces\",\"range\":[7,13]},{\"type\":{\"label\":\".\"},\"range\":[13,14]},{\"type\":{\"label\":\"name\"},\"value\":\"length\",\"range\":[14,20]},{\"type\":{\"label\":\"==/!=/===/!==\"},\"value\":\"===\",\"range\":[21,24]},{\"type\":{\"label\":\"num\"},\"value\":2,\"range\":[25,26]},{\"type\":{\"label\":\")\"},\"range\":[26,27]}]",
    visitorKeys: _powerAssertVisitorKeys
  }));
  var rubyBase = pieces[0];
  var rubyText = pieces[1];
  var strNode = (0, _parserUtils.createStrNode)(rubyBase, (0, _parserUtils.offsetContext)(context, tag.content.index));
  node.rubyText = rubyText;
  node.children = [strNode];
  return node;
}
/**
 * parse @<LaTex>{} tag.
 * @param {string} text - symbol substitute text
 * @param {Tag} tag - tag to parse
 * @param {Context} context - context of the node
 * @return {TxtNode}
 */


function parseSymbolTag(text, tag, context) {
  var node = (0, _parserUtils.createInlineNode)(_mapping.Syntax.Symbol, tag.fullText, context);
  node.value = text;
  return node;
}
/**
 * parse inline tags and StrNodes from line.
 * @param {string} text - Text of the line
 * @param {Context} context - context of the node
 * @return {[TxtNode]} TxtNodes in the line
 */


function parseText(text, context) {
  var _rec3 = new _powerAssertRecorder();

  (0, _assert["default"])(_rec3._expr(_rec3._capt(!_rec3._capt(_rec3._capt(text, "arguments/0/argument/callee/object").match(/[\r\n]/), "arguments/0/argument"), "arguments/0"), {
    content: "assert(!text.match(/[\\r\\n]/))",
    filepath: "src/inline-parsers.js",
    line: 282,
    ast: "{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"assert\",\"range\":[0,6]},\"arguments\":[{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"text\",\"range\":[8,12]},\"property\":{\"type\":\"Identifier\",\"name\":\"match\",\"range\":[13,18]},\"computed\":false,\"range\":[8,18]},\"arguments\":[{\"type\":\"RegExpLiteral\",\"pattern\":\"[\\\\r\\\\n]\",\"flags\":\"\",\"range\":[19,27]}],\"range\":[8,28]},\"prefix\":true,\"range\":[7,28]}],\"range\":[0,29]}",
    tokens: "[{\"type\":{\"label\":\"name\"},\"value\":\"assert\",\"range\":[0,6]},{\"type\":{\"label\":\"(\"},\"range\":[6,7]},{\"type\":{\"label\":\"!\"},\"value\":\"!\",\"range\":[7,8]},{\"type\":{\"label\":\"name\"},\"value\":\"text\",\"range\":[8,12]},{\"type\":{\"label\":\".\"},\"range\":[12,13]},{\"type\":{\"label\":\"name\"},\"value\":\"match\",\"range\":[13,18]},{\"type\":{\"label\":\"(\"},\"range\":[18,19]},{\"type\":{\"label\":\"regexp\"},\"value\":{\"pattern\":\"[\\\\r\\\\n]\",\"flags\":\"\"},\"range\":[19,27]},{\"type\":{\"label\":\")\"},\"range\":[27,28]},{\"type\":{\"label\":\")\"},\"range\":[28,29]}]",
    visitorKeys: _powerAssertVisitorKeys
  }));
  return parseNestedText(text, context, 0);
}

function parseNestedText(text, context, depth) {
  var nodes = [];
  var tag;

  while (tag = (0, _parserUtils.findInlineTag)(text)) {
    if (tag.precedingText !== '') {
      var node = (0, _parserUtils.createStrNode)(tag.precedingText, context);
      nodes.push(node);
      context = (0, _parserUtils.offsetContext)(context, node.raw.length);
    }

    var parser = InlineParsers[tag.name];

    if (parser) {
      var nestedContext = Object.assign({}, context);
      nestedContext = (0, _parserUtils.offsetContext)(nestedContext, tag.content.startIndex);
      var nestedNodes = parseNestedText(tag.content.raw, nestedContext, depth + 1);

      var _node = parser(tag, (0, _parserUtils.contextNeedsUnescapeBraces)(context));

      if (nestedNodes) {
        _node.children = nestedNodes;
      }

      nodes.push(_node);
    }

    context = (0, _parserUtils.offsetContext)(context, tag.fullText.length);
    text = tag.followingText;
  }

  if (depth > 0 && !nodes.length) {
    return null;
  }

  if (text.length) {
    var _node2 = (0, _parserUtils.createStrNode)(text, context);

    nodes.push(_node2);
  }

  return nodes;
}

function supportedInlineCommands() {
  return Object.keys(InlineParsers);
}
//# sourceMappingURL=inline-parsers.js.map