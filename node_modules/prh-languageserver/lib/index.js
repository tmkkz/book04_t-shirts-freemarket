"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const prh_1 = require("prh");
const vscode_uri_1 = require("vscode-uri");
const vscode_languageserver_1 = require("vscode-languageserver");
// https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md
class Handler {
    constructor(connection, documents) {
        this.connection = connection;
        this.documents = documents;
        this.state = "valid" /* valid */;
        this.engineCache = {};
        this.validationCache = {};
        this.connection.onInitialize(arg => this.onInitialized(arg));
        this.connection.onDidChangeConfiguration(arg => this.onDidChangeConfiguration(arg));
        this.connection.onDidChangeWatchedFiles(arg => this.onDidChangeWatchedFiles(arg));
        this.connection.onCodeAction(arg => this.onCodeAction(arg));
        this.connection.onExecuteCommand(arg => this.onExecuteCommand(arg));
        this.documents.onDidChangeContent(arg => this.onDidChangeContent(arg));
    }
    listen() {
        this.connection.listen();
    }
    onInitialized(params) {
        return {
            capabilities: {
                textDocumentSync: this.documents.syncKind,
                hoverProvider: false,
                completionProvider: void 0,
                signatureHelpProvider: void 0,
                definitionProvider: false,
                referencesProvider: false,
                documentHighlightProvider: false,
                documentSymbolProvider: false,
                workspaceSymbolProvider: false,
                codeActionProvider: true,
                codeLensProvider: void 0,
                documentFormattingProvider: false,
                documentRangeFormattingProvider: false,
                documentOnTypeFormattingProvider: void 0,
                renameProvider: false,
                documentLinkProvider: void 0,
                executeCommandProvider: {
                    commands: ["replace"],
                },
                experimental: false,
            },
        };
    }
    onDidChangeConfiguration(change) {
        this.connection.console.log(`onDidChangeConfiguration: ${JSON.stringify(change, null, 2)}`);
        const settings = change.settings;
        this.enable = !!settings.prh.enable;
        this.configPaths = settings.prh.configFiles || [];
        this.checkConfig();
        this.documents.all().forEach(document => this.validateAndSendDiagnostics(document));
    }
    onDidChangeContent(change) {
        this.validateAndSendDiagnostics(change.document);
    }
    onDidChangeWatchedFiles(change) {
        this.connection.console.log(`onDidChangeWatchedFiles: ${JSON.stringify(change, null, 2)}`);
        // 設定ファイルのいずれかが変更されたらキャッシュを捨てる
        const configChanged = change.changes.some(change => {
            const uri = vscode_uri_1.default.parse(change.uri);
            return Object.keys(this.engineCache).some(concatenatedRulePaths => {
                // 若干雑な条件だけど間違っててもさほど痛くないのでOK
                // rulePathはpwdからの相対パス表現なので注意
                const rulePaths = concatenatedRulePaths.split("|");
                return rulePaths.some(rulePath => {
                    if (uri.path.endsWith(rulePath)) {
                        this.connection.console.log(`matched: ${uri.path} - ${rulePath}`);
                        return true;
                    }
                    return false;
                });
            });
        });
        if (configChanged) {
            this.checkConfig();
            this.documents.all().forEach(document => this.validateAndSendDiagnostics(document));
        }
    }
    onCodeAction(params) {
        const textDocument = this.documents.get(params.textDocument.uri);
        const changeSet = this.makeChangeSet(textDocument);
        if (!changeSet) {
            return [];
        }
        return changeSet.diffs
            .filter(diff => {
            const index = textDocument.offsetAt(params.range.start);
            const tailIndex = textDocument.offsetAt(params.range.end);
            return diff.index === index && diff.tailIndex === tailIndex;
        })
            .map(diff => {
            const commandParams = {
                uri: textDocument.uri,
                version: textDocument.version,
                textEdit: {
                    range: params.range,
                    newText: diff.newText || "??",
                },
            };
            return {
                title: `→ ${diff.newText || "??"}`,
                command: "replace",
                arguments: [commandParams],
            };
        });
    }
    onExecuteCommand(args) {
        switch (args.command) {
            case "replace":
                this.executeReplace(args);
                break;
            case "applyAllQuickFixes":
                this.executeApplyAllQuickFixes(args);
                break;
            default:
                this.connection.console.log(`Unknown command: ${args.command}`);
        }
    }
    invalidateCache() {
        this.engineCache = {};
        this.validationCache = {};
    }
    checkConfig() {
        this.configPaths = this.configPaths || [];
        this.connection.console.log(`loadConfig: ${this.configPaths.join(", ") || "implicit"}`);
        this.invalidateCache();
        for (let configPath of this.configPaths) {
            if (!fs.existsSync(configPath)) {
                this.connection.console.log(`rule file not exists: ${configPath}`);
                if (this.state !== "invalid" /* invalid */) {
                    this.connection.window.showWarningMessage(`prh: 指定された設定ファイルが見つかりません ${configPath}`);
                }
                this.state = "invalid" /* invalid */;
                this.documents.all().forEach(document => this.clearDiagnostics(document));
                return;
            }
        }
        this.state = "valid" /* valid */;
    }
    makeChangeSet(textDocument) {
        if (!this.enable || this.state === "invalid" /* invalid */) {
            return null;
        }
        if (this.validationCache[textDocument.uri] && this.validationCache[textDocument.uri].version === textDocument.version) {
            return this.validationCache[textDocument.uri].changeSet;
        }
        delete this.validationCache[textDocument.uri];
        let configPaths;
        if (this.configPaths && this.configPaths[0]) {
            configPaths = this.configPaths;
        }
        else {
            const contentUri = vscode_uri_1.default.parse(textDocument.uri);
            if (contentUri.scheme !== "file") {
                return null;
            }
            let foundPath = prh_1.getRuleFilePath(contentUri.path);
            if (!foundPath) {
                this.connection.console.log(`rule file not found for ${textDocument.uri}`);
                return null;
            }
            this.connection.console.log(`rule file found: ${foundPath}`);
            configPaths = [foundPath];
        }
        let engine = this.engineCache[configPaths.join("|")];
        if (!engine) {
            try {
                engine = prh_1.fromYAMLFilePaths(...configPaths);
            }
            catch (e) {
                this.connection.console.error(e);
                if (e instanceof Error) {
                    this.connection.window.showErrorMessage(`prh: \`${e.message}\` from ${configPaths.join(" ,")}`);
                    return null;
                }
            }
            this.engineCache[configPaths.join("|")] = engine;
        }
        const changeSet = engine.makeChangeSet(textDocument.uri, textDocument.getText());
        if (!changeSet) {
            return null;
        }
        this.validationCache[textDocument.uri] = {
            version: textDocument.version,
            changeSet,
        };
        return changeSet;
    }
    makeDiagnostic(textDocument) {
        const changeSet = this.makeChangeSet(textDocument);
        if (!changeSet) {
            return null;
        }
        return changeSet.diffs.map(diff => {
            const start = textDocument.positionAt(diff.index);
            const end = textDocument.positionAt(diff.tailIndex);
            let message;
            this.connection.console.log(JSON.stringify(diff));
            diff.apply(textDocument.getText());
            if (diff.rule && diff.rule.raw && diff.rule.raw.prh) {
                message = `→${diff.newText || "??"} ${diff.rule.raw.prh}`;
            }
            else {
                message = `→${diff.newText || "??"}`;
            }
            return {
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                range: {
                    start,
                    end,
                },
                message,
                source: "prh",
            };
        });
    }
    validateAndSendDiagnostics(textDocument) {
        const diagnostics = this.makeDiagnostic(textDocument);
        this.connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: diagnostics || [] });
    }
    clearDiagnostics(textDocument) {
        this.connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: [] });
    }
    executeReplace(args) {
        if (!args.arguments || !args.arguments[0]) {
            return;
        }
        const commandParams = args.arguments[0];
        this.connection.console.log(JSON.stringify(commandParams));
        const textDocument = this.documents.get(commandParams.uri);
        if (commandParams.version !== textDocument.version) {
            this.connection.console.log(`Replace, document version mismatch: expected: ${commandParams.version}, actual: ${textDocument.version}`);
            return;
        }
        this.connection.workspace.applyEdit({
            documentChanges: [{
                    textDocument: {
                        uri: textDocument.uri,
                        version: textDocument.version,
                    },
                    edits: [commandParams.textEdit],
                }],
        }).then(result => {
            this.connection.console.log(`Apply edit: ${JSON.stringify(result)}`);
        }, e => {
            this.connection.console.error(`error on executeReplace: ${e}`);
        });
    }
    executeApplyAllQuickFixes(args) {
        if (!args.arguments || !args.arguments[0]) {
            return;
        }
        const textDocument = this.documents.get(args.arguments[0]);
        const changeSet = this.makeChangeSet(textDocument);
        if (!changeSet) {
            return;
        }
        const edits = changeSet.diffs.map(diff => this.getTextEditFromDiff(textDocument, diff));
        this.connection.workspace.applyEdit({
            documentChanges: [{
                    textDocument: {
                        uri: textDocument.uri,
                        version: textDocument.version,
                    },
                    edits,
                }],
        }).then(result => {
            this.connection.console.log(`Apply edit: ${JSON.stringify(result)}`);
        }, e => {
            this.connection.console.error(`error on executeApplyAllQuickFixes: ${e}`);
        });
    }
    getTextEditFromDiff(textDocument, diff) {
        const start = textDocument.positionAt(diff.index);
        const end = textDocument.positionAt(diff.tailIndex);
        return {
            range: { start, end },
            newText: diff.newText || "??",
        };
    }
}
exports.Handler = Handler;
{
    const connection = vscode_languageserver_1.createConnection();
    const documents = new vscode_languageserver_1.TextDocuments();
    documents.listen(connection);
    const handler = new Handler(connection, documents);
    handler.listen();
}
//# sourceMappingURL=index.js.map